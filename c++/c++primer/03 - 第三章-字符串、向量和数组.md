## 3.1 命名空间的 using 声明

使用 `using` 声明可以无需专门的前缀（形如命名空间::），声明形式 `using namespace::name`。

一旦声明了上述语句，就可以直接访问命名空间的名字：

```c++
#include <iostream>

using std::cin;

int main(int argc, const char * argv[]) {
    int i;
    cin >> i;       // 正确：cin 和 std::cin 含义相同
    cout << i;      // 错误：没有对应的 using 声明，必须使用完整的名字
    std::cout << i; // 正确：显示地从 std 中使用 cout
    return 0;
}
```

**头文件不应该包含 using 声明**

因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中有某个 `using` 声明，那么每个使用了该头文件的文件就会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生名字冲突。

## 3.2 标准库类型 string

### 3.2.1 定义和初始化 string 对象

```c++
string s1;          // 默认初始化，s1 是一个空字符串
string s2 = s1;     // s2 是 s1 的副本
string s3 = "hiya"; // s3 是该字符串字面值的副本
string s4(10, 'c'); // s4 的内容是 cccccccccc
```

**直接初始化和拷贝初始化**

如果使用 `=` 初始化变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到创建的对象中去。如果不使用等号，则执行的是直接初始化。

```c++
string s5 = "hiya"; // 拷贝初始化
string s6("hiya");  // 直接初始化
string s7(10, 'c'); // 直接初始化，s7 的内容是 cccccccccc
```

**string::size_type 类型**

`size` 函数返回的是一个 `string::size_type` 类型的值。它是一个无符号类型的值。所有用于存放 `string` 类的 `size` 函数返回值的变量，都应该是 `string::size_type` 类型。

由于 `size` 函数返回的是一个无符号整型数，因此，如果在表达式中混用了带符号和无符号数降可能产生意想不到的结果。例如，假设 `n` 是一个具有负值的 int，则表达式 `s.size() < n` 的结果几乎肯定是 `true`，因为负值 `n` 会自动转换成一个比较大的无符号值。

**比较 string 对象**

相等性运算符： `==` `!=`
关系运算符：`<` `<=` `>` `>=`

**两个 string 对象相加**

```c++
string s1 = "hello, ", s2 = "world\n";
string s3 = s1 + s2;   // s3 的内容是 hello, world\n
s1 += s2;              // 等价于 s1 = s1 + s2
```

**字面值和 string 对象相加**

当把 `string` 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符两侧的运算对象至少有一个是 `string`：

```c++
string s4 = s1 + ", ";      // 正确：把一个 string 对象和一个字面值相加
string s5 = "hello" + ", "  // 错误：两个运算符对象都不是 string
// 正确：每个加法运算符都有一个运算对象是 string
string s6 = s1 + ", " + "world"
string s7 = "hello" + ", " + s2; // 错误：不能把字面值相加
```

`s5` 表达式中，先计算 `s1 + ", "`，结果是一个 `string` 对象，所以可以再继续和`"world"` 相加。

> 因为某些历史原因，也为了与 C 兼容，所以 C++ 语言中的字符串字面值并不是标准库类型的 `string` 对象。切记，字符串字面值与 `string` 是不同的类型。

### 3.2.3 处理 string 对象中的字符

**处理每个字符？使用基于范围的 for 语句**

```c++
string str("some thing");
for (auto s : str) {
    cout << s << endl;
}
```

**只处理一部分字符？**

**下标运算符**：`string` 对象的下标从 `0` 记起。如果 `string` 对象 `s` 至少包含两个字符，则 `s[0]` 是第一个字符、`s[1]` 是第二个字符、`s[s.size() - 1]` 是最后一个字符。

> `string` 对象的下标必须大于等于 `0` 而小于 `s.size()`。

## 3.3 标准库类型 vector

`vector` 表示对象的集合，其中所有对象的内容都相同。集合中每个对象都有一个与之对应的索引。它是一个类模板（相当于其他语言的泛型）。

编译器根据模板创建类或函数的过程成为**实例化**。

```c++
vector<int> ivec;              // 保存着 int 类型的对象
vector<Sales_item> sales_vec;  // 保存 Sales_item 类型的对象
vector<vector<string>> file;   // 该向量的元素是 vector 对象
```

`vector` 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 `vector`。

### 3.3.1 定义和初始化 vector 对象

定义 `vector` 对象的常用方法：

```c++
// v1 是一个空 vector，潜在的元素是 T 类型，执行默认初始化
vector<T> v1;

// v2 中包含 v1 所有元素的副本
vector<T> v2(v1);

// 等价于 v2(v1)，v2 中包含 v1 所有元素的副本
vector<T> v2 = v1;

// v3 包含了 n 个重复的元素，每个元素的值都是 val
vector<T> v3(n, val)

// v4 包含了 n 个重复地执行了值初始化的对象
vector<T> v4(n);

// v5 包含了初始值个数的元素，每个元素被赋予响应的初始值
vector<T> v5{a, b, c...}

// 等价于 v5{a, b, c...}
vector<T> v5 = {a, b, c...}
```

### 3.3.2 向 vector 对象中添加元素

**push_back：把元素添加到尾端**

```c++
vector<int> v2;      // 空的 vector 对象
for (int i = 0; i != 100; i++) {
    v2.push_back(i); // 依次把数组放到 v2 微端
}
```

> 在 C++ 标准中 `vector` 对象能高效增长，所以定义 `vector` 对象时就没必要设定其大小，事实上如果这么做性能可能更差。只有一种例外的情况，就是所有元素的值都一样。

> 范围 for 语句体内不应该改变其所遍历程序的大小。

### 3.3.3 其他 vector 操作

```c++
// 如果 v 不含有任何元素，返回真；否则返回假
v.empty()

// 返回 v 中的元素个数
v.size()

// 向 v 的尾端添加一个值为 t 的元素
v.push_back(t)

// 返回 v 中的第 n 个位置上元素的引用
v[n]

// 用 v2 中的元素拷贝替换 v1 中的元素
v1 = v2

// 用列表中元素拷贝替换 v1 中的元素
v1 = {a, b, c...}

// v1 和 v2 相当当且仅当他们的元素数量相同且对应位置的元素都相同
v1 == v2
v1 != v2

// 以字典顺序进行比较
<, <=, >, >=  
```

`v.size()` 的返回值类型是由 `vector` 对象定义的 `size_type` 类型。要使用 `size_type`，需要先指定它是由哪种类型定义的：

```c++
vector<int>::size_type  // 正确
vector::size_type       // 错误
```

**不能用下标形式添加元素**

```c++
vector<int> ivec;  // 空 vector 对象
for (decltype(ivec.size()) ix = 0; ix != 10; ix++) {
    ivec[ix] = x;  // 严重错误：ivec 不包含任何元素
}
```

`vector` 对象（以及 `string` 对象）的下标运算符可用于访问已存在的元素，不能用于添加元素。

## 3.4 迭代器介绍

### 3.4.1 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。例如，这些类型都拥有名为 `begin` （返回指向第一个元素的迭代器） 和 `end` 的成员：

```c++
// b 表示 v 的第一个元素，e 标识 v 尾元素的下一个位置
auto b = v.begin(), e = v.end(); // b 和 e 的类型相同
```

`end` 成员则负责返回指向容器“尾元素的下一个位置”的迭代器，也就是说，该迭代器指示的是容器的一个不存在的 **“尾后”** 元素。这种迭代器通常被称为**尾后迭代器**或简称为**尾迭代器**。

特殊情况下如果容器为空，则 `begin` 和 `end` 返回的都是同一个迭代器，都是尾后迭代器。

**迭代器运算符**

```c++
// 返回迭代器 iter 所指元素的引用
*iter

// 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem
iter->mem

// 令 iter 指示容器中的下一个元素
++iter

// 令 iter 指示容器中的上一个元素
--iter

// 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素
// 或者它们是同一个容器的尾后迭代器，则相等；反之，不相等
iter1 == iter2
iter1 != iter2
```

和指针类似，能通过解引用迭代器来获取它所指是的元素，执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是为被定义的行为。

**将迭代器从一个元素移动到另外一个元素**

迭代器使用递增（`++`）运算符来从一个元素移动到下一个元素。

> 因为 `end` 返回的迭代器并不实际只是某个元素，所以不能对其他进行递增或解引用操作。

> 原来使用 C 或者 Java 的程序员在转而使用 C++ 语言之后，会对 for 循环中使用 `!=` 而非 `<` 进行判断有点奇怪。C++ 程序员习惯性地使用 `!=`，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器都有效。只有 `string` 和 `vector` 等一些标准库有下标运算符，而并非如此。所有标准库容器的迭代器都定义了 `==` 和 `!=`，但是它们中的大多数都没有定义 `<` 运算符。因为我们要养成使用迭代器和 `!=` 的习惯，就不用太在意用的到底是那种容器类型。

**迭代器类型**

就像不知道 `string` 和 `vector` 的 `size_type` 的成员到底是什么类型一样，一般来说我们也不知道（其实无需知道）迭代器的精确类型。实际上，那些拥有迭代器的标准库类型使用 `iterator` 和 `const_iterator` 来表示迭代器的类型：

```c++
vector<int>::iterator it;   // it 能读写 vector<int> 的元素
string::iterator it2;       // it2 能读写 string 对象中的字符

vector<int>::const_iterator it3;   // it3 只能读元素，不能写元素
string::const_iterator it4;        // it4 只能读字符，不能写字符
```

`const_iterator` 和常量指针差不多，能读取但不能修改它所指向的元素值。相反，`iterator` 的对象可以读写。如果 `vector` 对象或 `string` 对象是一个常量，只能使用 `const_iterator`；如果不是常量，则可以使用 `iterator` 或者 `const_iterator`。

**begin 和 end 运算符**

`begin` 和 `end` 返回的具体类型由对象是否是常量决定，如果是常量，则返回 `const_iterator`，如果不是常量，返回 `iterator`：

```c++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();      // it1 的类型 vector<int>::iterator
auto it2 = cv.begin();     // it2 的类型 vector<int>::const_iterator
```

有时候这种默认行为并非我们想要的。如果对象只需读操作而无需写操作则最好使用常量类型。为了便于专门得到 `const_iterator` 类型的返回值，C++ 新标准引入了两个新函数，分别是 `cbegin` 和 `cend`：

```c++
auto it3 = v.cbegin(); // it3 的类型 vector<int>::const_iterator
```

**结合解引用和成员访问操作**

假设 `it` 是字符串组成的 `vector` 对象的迭代器，要想检查元素是否为空，只需判断 `it` 所指字符串是否为空就可以：

```c++
(*it).empty() // *it 两边的括号必不可少
```

**箭头运算符**把解引用和成员访问两个操作结合在一起，也就是 `it->mem` 和 `(*it).mem` 表达的意思相同。

```c++
for (auto it = .text.cbegin(); it != text.cend() && !it->.empty(); ++it) {
    cout << *it << endl;
}
```

**某些对 vector 对象的操作会使迭代器失效**

但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

### 3.4.2 迭代器运算

`vector` 和 `string` 迭代器支持的运算：

```c++
// 迭代器加上一个整数值仍得一个迭代器，向前移动了若干个元素，
// 结果是指向一个元素或者尾元素的下一个位置
iter + n

// 迭代器减去一个整数值仍得一个迭代器，向后移动了若干个元素，
// 结果是指向一个元素或者尾元素的下一个位置
iter - n

// 将 iter1 加 n 的结果赋给 iter1
iter1 += n

// 将 iter1 减 n 的结果赋给 iter1
iter1 -= n

// 结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。
// 参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置。
// 结果类型是 difference_type 的带符号整型数，string 和 vector 都定义了 difference_type，因为距离可正可负，所以 difference_type 是带符号类型的。
iter1 - iter2

// 如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说明前者小于后者。
// 参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置
>、 >=、 <、 <=
```

**迭代器的算术运算**

```c++
// 计算得到最接近 v1 中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```

**使用迭代器运算**

二分搜索：

```c++
// text 必须是有序的
vector<string> text;
auto begin = text.begin();
auto end = text.end();
auto mid = text.begin() + (end - begin) / 2;

string sought;

while (mid != end && *mid != sought) {
    if (sought < *mid) {
        end = mid;
    } else {
        begin = mid + 1;
    }
    mid = begin + (end - begin) / 2;
}
```

## 3.5 数组

与 vector 不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但也相应地损失了一些灵活性。

### 3.5.1 定义和初始化内置数组

数组是一个复合类型，声明形式形如 `a[d]`，`a` 是数组的名字，`d`是数组的维度。维度是数组中元素的个数，因此必须大于 0。数组中元素的个数也属于数组类型的一部分，编译时维度应该是已知的。因此维度必须是一个常量表达式：

```c++  
unsigned cnt = 42;           // 不是常量表达式
constexpr unsigned sz = 42;  // 常量表达式
int arr[10];                 // 含有 10 个整数的数组
int *parr[sz];               // 含有 42 个整型指针的数组
string bad[cnt];             // 错误：cnt 不是常量表达式
string strs[get_size()];     // 当 get_size 是 constexpr 时正确；否则错误
```

默认情况下，数组的元素被默认初始化。

定义数组时必须指定数组的类型，不允许使用 `auto` 由初始值的列表推断类型。另外和 `vector` 一样，数组的元素应为对象，因此不存在引用数组。

**显式初始化数组元素**

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果声明时没有指定维度，编译器会根据初始值的数量计算并推测出来；如果指定了维度，那么初始值的总数量不应该超过指定大小。如果维度比初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值：

```c++
const unsigned sz = 3;          
int ia1[sz] = { 0, 1, 2 };      // 含有 3 个元素的数组，值分别为 0, 1, 2
int a2[] = { 0, 1, 2 };         // 维度是 3 的数组
int a3[5] = { 0, 1, 2 };        // 等价于 a3 = { 0, 1, 2, 0, 0 }
string a4[3] = { "hi", "bye" }; // 等价于 a4 = { "hi", "bye", "" }
int a5[2] = { 0, 1, 2 };        // 错误：初始值过多
```

**字符数组的特殊性**

字符数组有一种额外的初始化形式，我们可以利用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char a1[] = { 'C', '+', '+' };        // 列表初始化，没有空字符
char a2[] = { 'C', '+', '+', '\0' };  // 列表初始化，含有显式的空字符
char a3[] = "C++";                    // 自动添加表示字符串结束的空字符
const char a4[6] = "Daniel";          // 错误：没有空间存放空字符
```

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其它数组赋值：

```c++
int a[] = { 0, 1, 2 }; // 含有三个整数的数组
int a2[] = a;          // 错误：不允许使用一个数组初始化另一个数组
a2 = a;                // 错误：不能把一个数组直接赋值给另一个数组
```

**理解复杂数组声明**

```c++
int *ptrs[10];            // ptrs 是含有 10 个整型指针的数组
int &refs[10] = /* ? */;  // 错误：不存在引用的数组
int (*Parray)[10] = &arr; // Parray 指向一个含有 10 个整数的数组
int (&arrRef)[10] = arr;  // arrRef 引用一个含有 10 个整数的数组
int *(&array)[10] = ptrs; // array 是数组的引用，该数组含有 10 个指针
```

`ptrs`：从右向左，首先定义的是一个大小为 10 的数组，名字是 `ptrs`，存放的是指向 int 的指针。
`Parray`：由内向外，首先括号部分 `*Parray` 意味着 `Parray` 是一个指针；右边`[10]` 表示指向大小为 10 的数组的指针；左边 `int`表示数组的元素是 `int` 类型。
`array`：由内向外，`&array` 表示 `array` 是一个引用；右边`[10]` 表示引用的对象是大小为 10 的数组；左边 `int *`表示数组的元素是指向 `int` 的指针。

> 要想理解数组的声明含义，最好的办法是从数组的名字开始由内向外的顺序阅读。

### 3.5.2 访问数组元素

与 `vector` 和 `string` 一样，数组元素也能使用范围 for 语句或下标运算符来访问。

在使用数组下标时，通常将其定义为 `size_t` 类型。它是一种及其相关的无符号类型，它被设计得足够大以便能表示内存中人以对象的大小。

### 3.5.3 指针和数组

```c++
string nums[] = { "one", "two", "three" }; // 数组元素是 string 对象
string *p = &nums[0];                      // p 指向 nums 的第一个元素
```

数组还有一个特性：在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针：

```c++
string *p2 = nums; // 等价于 p2 = &nums[0]
```

> 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

在一些情况下数组的操作实际上是指针的操作。这个结论有很多隐含的意思。其中一个是当使用数组作为一个 `auto` 变量的初始值时，推断得到的类型是指针而非数组：

```c++
int ia[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // 含有 10 个整数的数组
auto ia2(ia);    // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;        // 错误：ia2 是一个指针，不能用 int 值给指针赋值
```

尽管 `ia` 是由 10 个整数构成的数组，但当使用 `ia` 作为初始值时，编译器实际执行的初始化过程类似于下面的形式：

```c++
auto ia2(&ia[0]); // 显然 ia2 的类型是 int*
```

当使用 `decltype` 时，上述转换不会发生：

```c++
// ia3 是一个含有 10 个整数的数组
decltype(ia) ia3 = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
ia3 = p;    // 错误：不能用整型指针给数组赋值
ia3[4] = i; // 正确：把 i 的值赋给 ia3 的一个元素
```

**指针也是迭代器**

指向数组元素的指针拥有更多功能。`vector` 和 `string` 的迭代器支持的运算，数组的指针全都支持。例如，允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```c++
int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int *p = arr;   // p 指向 arr 的第一个元素
++p;            // p 指向 arr[1]
```

**标准库函数 begin 和 end**

尽管能通过计算得到尾后指针（`&arr[10]`），但容易出错。为了使用更简单安全， C++11 新标准引入了两个名为 `begin` 和 `end` 的函数（数组不是类类型，所以不是成员函数）：

```c++
int ia[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
int *beg = begin(ia); // 指向 ia 首元素的指针
int *last = end(ia);  // 指向 arr 尾元素的下一位置的指针
```

`begin` 和 `end` 定义在 `iterator` 头文件中。

使用 `begin` 和 `end` 可以很容易写出一个循环并处理数组中的元素。例如，在一个整形数组中找到第一个负数：

```c++
int *pbeg = begin(arr), *pend = end(arr);
while (pbeg != pend && *pbeg >= 0) {
    ++pbeg;
}
```

**指针运算**

指向数组元素的指针可以执行迭代器的运算，包括：解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。

给（从）一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：

```c++
constexpr size_t sz = 5;
int arr[sz] = { 1, 2, 3, 4, 5 };
int *ip = arr;       // 等价于 int *ip = &arr[0]
int *ip2 = ip + 4;   // ip2 指向 arr 的尾元素 arr[4]

// 正确，arr 转换成指向它首元素的指针；p 指向 arr 尾元素的下一位置
int *p = arr + sz;     // 使用警告：不要解引用
int *p2 = arr + 10;    // arr 只有 5 个元素，p2 的值未定义

auto n = end(arr) - begin(arr);  // n 的值是 5，也就是 arr 中元素的数量
```

只要两个指针指向同一个数组的元素或者尾元素的下一位置，就能利用关系运算符对其进行比较。例如，可以使用下列方式遍历数组中的元素：

```c++
int *b = arr, *e = arr + sz;
while (b < e) {
    // 使用 *b
    ++b;
}
```

**解引用和指针运算的交互**

指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该指针：

```c++
int ia[] = { 0, 2, 4, 6, 8 };
int last = *(ia + 4);  // 正确：把 last 初始化成 8，也就是 ia[4] 的值
```

此例中的括号必不可少。如果去掉括号，意义则完全不同：

```c++
last = *ia + 4;  // 正确：last = 4 等价于 ia[0] + 4
```

**下标和指针**

在很多情况下，使用数组名字其实用的是一个指向数组首元素的指针。当对数组使用下标运算时，编译器会自动执行上述转换操作。给定：

```c++
int ia[] = { 0, 2, 4, 6, 8 };
```

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```c++
// ia 转换成指向数组首元素的指针，ia[2] 得到 (ia + 2) 所指的元素
int i = ia[2];

int *p = ia;  // p 指向 ia 的首元素
i = *(p + 2); // 等价于 i = ia[2]
```

只要指针指向的是数组中的元素（或者尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // 指向索引为 2 的元素
int j = p[1];    // p[1] 等价于 *(p + 1)，就是 ia[3] 表示的那个元素
int k = p[-2];   // p[-2] 是 ia[0] 表示的那个元素
```

虽然标准库类型 `string` 和 `vector` 也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。内置的下标运算可以处理负值。

### 3.5.4 C 风格字符串

> 尽管 C++ 支持 C 风格字符串，但在 C++ 程序中最好还是不要使用它们。因为 C 风格字符串不仅使用起来不方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

C 风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按照此习惯书写的字符串存放在字符数组中并以**空字符结束**。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（`\0`）。一般利用指针来操作这些字符串。

**C 标准库 String 函数**

C 风格字符串的函数：

```c++
// 返回 p 的长度，空字符不计算在内
strlen(p)

// 比较相等性。如果 p1 == p2，返回 0；如果 p1 > p2，返回一个正值；
// 如果 p1 < p2，返回一个负值
strcmp(p1, p2)

// 将 p2 附加到 p1 之后，返回 p1
strcat(p1, p2)

// 将 p2 拷贝给 p1，返回 p1
strcpy(p1, p2)
```

传入此类函数的指针必须指向以空字符作为结束的数组：

```c++
char ca[] = { 'C', '+', '+' };  // 不以空字符结束
cout << strlen(ca) << endl;     // 严重错误：ca 没有以字符串结束
```

此例中，`ca` 虽然也是一个字符数组但不是以空字符结束，因此上述程序将产生未定义的结果。`strlen` 函数将有可能沿着 `ca` 在内存中的位置不断向前寻找，直到遇到空字符才停下来。

**比较字符串**

比较标准库 `string` 对象时，用普通的关系运算符和相等性运算符：

```c++
string s1 = "A string example";
string s2 = "A different string";
if (s1 < s2)  // false: s2 小于 s1
```

如果把这些运算符用在两个 C 风格字符串上，实际上比较的是指针而非字符串本身：

```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2)  // 未定义的：试图比较两个无关的地址
```

当使用数组时，其实真正用的是指向数组首元素的指针。因此，上面实际比较的是两个 `const char*` 的值。这两个指针指向的并非同一对象，所以得到未定义的结果。

要想比较两个 C 风格的字符串需要调用 `strcmp` 函数。如果相等，返回 0；如果前面的大，返回正值；如果后面的大，返回正值：

```c++
if (strcmp(ca1, ca2) < 0)
```

**目标字符串的大小由调用者指定**

连接或拷贝 C 风格字符串与标准库 `string` 对象的同类操作差别很大。例如把刚刚那两个 `string` 连接起来，可以直接写成：

```c++
// 将 s1、空格、s2 连接
string largeStr = s1 + " " + s2;
```

同样的操作放在 `ca1` 和 `ca2` 就不行，应该使用 `strcat` 和 `strcpy`函数。另外，要想使用这两个函数，还必须提供一个用于粗放结果字符串的数组，该数组必须足够大以便容纳下结果字符串以及末尾的空字符。下面的代码很常见，但是充满了安全风险，极易引发错误：

```c++
strcpy(largeStr, ca1); // 把 ca1 拷贝给 largeStr
strcat(largeStr, " "); // 在 largeStr 的末尾加上一个空格
strcat(largeStr, ca2); // 把 ca2 连接到 largeStr 后面
```

一个潜在的问题是，在估算 `largeStr` 所需的空间不容易估准。而且 `largeStr` 所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码都出都是，程序员根本无法照顾周全，这类代码充满了风险而且经常导致眼中的安全泄露。

> 对大多数应用来说，使用标准库 `string` 要比使用 C 风格字符串更安全、更高效。

### 3.5.5 与旧代码的接口

**混用 string 对象和 C 风格字符串**

之前说过允许使用字符串字面值来初始化 string 对象：

```c++
string s("Hello World");
```

更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

- 允许使用以空字符结束的字符数组来初始化 `string` 对象或为 `string` 对象赋值。
- 在 `string` 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在 `string` 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

如果程序的某处需要一个 C 风格的字符串，无法直接用 `string` 对象来代替它，可以使用 `string` 的 `c_str` 成员函数：

```c++
char *str = s;                 // 错误：不能用 string 对象初始化 char*
const char *str = s.c_str();   // 正确
```

顾名思义，`c_str` 的返回值是一个 C 风格的字符串，也就是说返回的结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 `string` 对象一样。结果指针类型是 `const char*`，从而确保我们不会改变字符数组的内容。

我们无法保证 `c_str` 函数返回的数组一直有效，事实上，如果后续的操作改变了 `s` 的值就可能让之前返回的数组失去效用。

> 如果执行完 `c_str` 函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。

**使用数组初始化 vector 对象**

指明需要拷贝的首元素地址和尾后地址：

```c++
int arr[] = { 0, 1, 2, 3, 4, 5 };
vector<int> vec(begin(arr), end(arr));
```

用于初始化 `vector` 对象的值也可能仅是数组的一部分：

```c++
// 拷贝三个元素： arr[1]、arr[2]、arr[3]
vector<int> vec(arr + 1, arr + 4);
```

> 尽量使用标准库类型而非数组。使用指针和数组很容易出错。现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；应该尽量使用 string，避免使用 C 风格的基于数组的字符串。

## 3.6 多维数组

当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）大小：

```c++
int ia[3][4]; // 大小为 3 的数组，每个元素是含有 4 个整数的数组

// 大小为 10 的数组，它的每个元素都是大小为 20 的数组，
// 这些数组的元素是含有 30 个整数的数组
int arr[10][20][30] = {0};  // 将所有元素初始化为 0
```

对于二维数组来说，常把第一个维度称作行，第二维度称作列。

**多维数组的初始化**

```c++
int ia[3][4] = {     // 三个元素，每个元素都是大小为 4 的数组
    { 0, 1, 2, 3 },  // 第一行的初始值
    { 4, 5, 6, 7 },  // 第二行的初始值
    { 8, 9, 10, 11}  // 第三行的初始值
};
```

其中内层嵌套的花括号并非必需的，例如上面的代码可以简化为：

```c++
// 没有标识每行的花括号，与之前的初始化语句时等价的
int ia[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
```

类似于一维数组，在初始化多维数组时并非所有元素都必须包含在初始化列表之内：

```c++
// 显式地初始化每行的首元素
int ia[3][4] = { { 0 }, { 4 }, { 8 } };
```

其他未列出的元素执行默认值初始化，这个过程和一维数组一样。在这种情况下，如果省略花括号，结果就大不一样了：

```c++
// 显式地初始化第一行，其他元素执行值初始化
int ia[3][4] = { 0, 3, 6, 9 };
```

**多维数组的下标引用**

```c++
// 用 arr 的首元素为 ia 最后一行最后一个元素赋值
ia[2][3] = arr[0][0][0];

// 把 row 绑定到 ia 的第二个 4 元素数组上
int (&row)[4] = ia[1];
```

在第二个例子中，把 `row` 定义成一个含有 4 个整数的数组的引用，然后将其绑定到 `ia` 的第二行。

**使用返回 for 语句处理多维数组**

```c++
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        cnt++;
    }
}
```

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实我们还有一个深层次的原因促使我们这么做。例如：

```c++
for (const auto &row : ia)
    for (auto col : row)
        cout << col << endl;
```

这个循环中并没有任何写操作，可是还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针。如果不用引用类型，程序无法通过编译。

> 要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

**指针和多维数组**

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

```c++
int ia[3][4];      
int (*p)[4] = ia; // p 指向含有 4 个整数的数组
p = &ia[2];       // p 指向 ia 的尾元素
```

p 是指向含有 4 个整数的数组的指针。

**注意**：在上述声明中，括号必不可少：

```c++
int *ip[4];   // 整型指针的数组
int (*ip)[4]; // 指向含有 4 个整数的数组
```

随着 C++11 新标准的提出，通过使用 `auto` 或者 `decltype` 就能尽可能避免在数组前面加一个指针类型了：

```c++
// 输出 ia 中每一个元素的值，每个内层数组占一行
// p 指向含有 4 个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
    // q 指向 4 个整数数组的首元素，也就是说，q 指向一个整数
    for (auto q = *p; q != *p + 4; ++q) {
        cout << *q << " ";
    }
    cout << endl;
}
```

外层 `for` 循环首先声明一个指针 `p` 并令其指向 `ia` 的第一个内层数组，然后一次迭代直到 `ia` 的全部三行都处理完为止。`++p` 负责将 `p` 移动到 `ia` 的下一行。

内层 `for` 循环负责输出内层数组所包含的值。首先令 `q` 指向 `p` 当前所在行的第一个元素。`*p` 是一个含有 4 个整数的数组，数组名被自动转换成指向该数组首元素的指针。

**类型别名简化多维数组的指针**

```c++
// 新标准下类型别名的声明
using int_array = int[4];

// 等价的 typedef 声明
typedef int int_array[4];

// 输出 ia 中每个元素的值，每个内层数组各占一行
for (int_array *p = ia; p != ia + 3; ++p) {
    for (int *q = *p; q != *p + 4; ++q) {
        cout << *q << " ";
    }
    cout << endl;
}
```
