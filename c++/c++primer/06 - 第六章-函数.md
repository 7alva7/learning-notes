## 6.1 函数基础

一个典型的函数定义包括以下部分：返回类型、函数名字、有 0 个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一个队圆括号之内。函数执行的操作在语句块中说明，该语句块成为函数体。

**编写函数**

编写一个求数的阶乘的程序：

```c++
int fact(int val) {
    int res = 1;
    while (val > 1) {
        res *= val--;
    }
    return res;
}
```

函数的名字是 `fact`，它作用于一个整型参数，返回一个整型值。在 while 循环内部，在每次迭代时用后置递减运算符将 `val` 的值减 `1`。return 语句负责结束 `fact` 并返回 `res` 的值。

**调用函数**

要调用 `fact` 函数，必须提供一个整数值，调用得到的结果也是一个整数：

```c++
int main() {
    int j =fact(5);
    cout << "5! is " << j << endl;
    return 0;
}
```

函数的调用完成两项工作：1）用实参初始化函数对应的形参；2）将控制权转移给被调用的函数。此时，主调函数的执行被暂时中断，被调函数开始执行。

当遇到一条 return 语句时函数结束执行过程。return 语句完成两项工作：1）返回 return 语句中的值（如果有的话）；2）将控制权从被调用函数转移回主调函数。

**形参和实参**

实参是形参的初始值，第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。

实参的类型必须与对应的形参类型匹配。

在上面的例子中，`fact` 函数只有一个 int 类型的形参，所以每次调用它的时候，都必须提供一个能转换成 int 的实参：

```c++
fact("hello");     // 错误：实参类型不正确
fact();            // 错误：实参数量不足
fact(42, 10, 0);   // 错误：实参数量过多
fact(3.14);        // 正确：该实参能转换成 int 类型；等价于 fact(3);
```

**函数的形参列表**

函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。不过为了与 C 语言兼容，也可以使用关键字 void 标识函数没有形参：

```c++
void f1() { }       // 隐式地定义空形参列表
void f2(void) { }   // 显式地定义空形参列表
```

形参列表中的形参用逗号隔开，并且每个形参都含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：

```c++
int f3(int v1, v2) { }      // 错误
int f4(int v1, int v2) { }  // 正确
```

任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

**函数返回类型**

大多数类型都能用作函数的返回类型。一种特殊的返回类型是 void，它表示函数不返回任何值。函数的返回类型不能是数组类型或参数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

在 C++ 语言中，名字有作用域，对象有生命周期：

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在的一段时间。

函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内定义的变量统称为**局部变量**。它们对函数而言是“局部”的，尽在函数的作用域内可见，同时局部变量还会**隐藏**在外层作用域中的同名的其他所有声明。

在所有函数体内之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。

**局部静态对象**

某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成 static 类型从而获得这样的对象。**局部静态变量**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

例如，下面的函数统计它自己被调用了多少次：

```c++
size_t count_calls() {
    static size_t ctr = 0;
    return ++ctr;
}

int main() {
    // 输出 1 到 10 的数字
    for (size_t i = 0; i != 10; ++i) {
        cout << count_calls() << endl;
    }
    return 0;
}
```

如果局部静态变量没有显示的初始值，它将执行值初始化，内置类型的局部静态变量初始化为 0。

### 6.1.2 函数声明

类似于变量，函数只能定义一次，但可以声明多次。唯一的例外是：如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。

函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。

因为函数声明不包含函数体，所以也就无需形参的名字。在函数声明中经常省略形参的名字。尽管如此，写上形参还是有用处的，他可以帮助使用者更好地理解函数的功能。

```c++
void print(vector<int>::const_iterator beg, 
            vector<int>::const_iterator end);
```

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息。函数的声明也称作**函数原型**。

**在头文件中进行函数声明**

我们建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明在源文件中定义。

定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

### 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

## 6.2 参数传递

每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。

> 形参初始化的机理与变量初始化一样。

当形参是引用类型时，我们说它对应的实参被**引用传递**或者函数被**传引用调用**。

当实参的值被拷贝给形参时，形参和实参是两个互相独立的对象。我们说这样的实参被**值传递**或者函数被**传值调用**。

### 6.2.1 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值：

```c++
int n = 0;  // int 类型的初始变量
int i = n;  // i 是 n 的值的副本
i = 42;     // i 的值改变，n 的值不变
```

传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参。

**指针形参**

指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。

```c++
void reset(int *ip) {
    *ip = 0;  // 改变指针 ip 所指对象爱的值
    ip = 0;   // 只改变了 ip 的局部拷贝，实参未被改变
}
```

调用 `reset` 函数之后，实参所指的对象被置为 0，但是实参本身并没有改变：

```c++
int i = 42;
reset(&i);                      // 改变 i 的值而非 i 的地址
cout << "i = " << i << endl;    // 输出 i = 0
```

> 熟悉 C 的程序员常常使用指针类型的形参访问函数外部的对象。在 C++ 语言中，建议使用引用类型的形参代替指针。

### 6.2.2 传引用参数

对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。通过使用引用参数，允许函数改变一个或多个实参的值。

例如，改写上一节的 `reset`，使其接受的参数是引用类型而非指针：

```c++
// 该函数接收一个 int 对象的引用，然后将对象的值置为 0
void reset(int &i) { // i 是传给 reset 函数的对象的另一个名字
    i = 0;           // 改变了 i 所引对象的值
}
```

调用这一版本的 `reset` 函数时，我们直接传入对象而无需传递对象的地址：

```c++
int j = 42;
reset(j);                      // j 采用传引用方式，它的值被改变
cout << "j = " << j << endl;   // 输出 j = 0
```

**使用引用避免拷贝**

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括 IO 类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。

例如，编写一个函数比较两个 string 对象的长度。因为 string 对象可能会非常长，所以尽量避免直接拷贝它们，这是使用引用形参是比较明智的选择。又因为比较长度无需改变 string 对象的内容，所以把形参定义成对常量的引用：

```c++
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}
```

> 如果函数无需改变引用形参的值，最好将其声明为常量引用。

**使用引用形参返回额外信息**

一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。

例如：定义一个名为 `find_char` 的函数，它返回在 string 对象中某个指定字符第一次出现的位置，同时我们希望函数能返回该字符出现的总次数。一种方法是定义一个新的数据类型，让它包含位置和数量两个成员。另外一种更简单的方法是：给函数传入一个额外的引用实参，令其保存字符出现的总次数：

```c++
// 返回 s 中 c 第一次出现的位置索引
// 引用形参 occurs 负责统计 c 出现的总次数
string::size_type find_char(const string &s, char c, string::size_type &occurs) {
    auto ret = s.size(); // 第一次出现的位置（如果有的话）
    occurs = 0;          // 设置表示出现次数的形参的值
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size()) {
                ret = i; // 记录 c 第一次出现的位置
            }
            ++occurs;    // 将出现的次数加 1
        }
    }
    return ret;          // 出现次数通过 occurs 隐式地返回
}
```

### 6.2.3 const 形参和实参

顶层 const 作用域对象本身：

```c++
const int ci = 42;  // 不能改变 ci，const 是顶层的
int i = ci;         // 正确，当拷贝 ci 时，忽略了它的顶层 const
int * const p = &i; // const 是顶层的不能给 p 赋值
*p = 0;             // 正确：通过 p 改变对象的内容是允许的，现在 i 变成了 0
```

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层 const。当形参有顶层 const 时，传给它常量对象或者非常量对象都是可以的：

```c++
void fcn(const int i) { /* fcn 能够读取 i，但是不能向 i 写值 */ }
```

调用 `fcn` 函数时，既可以传入 const int 也可以传入 int。 忽略掉形参的顶层 const 可能产生意想不到的后果：

```c++
void fcn(const int i) { /* fcn 能够读取 i，但是不能向 i 写值 */ }
void fcn(int i) { /* 错误：重复定义了 fcn(int) */ }
```

在 C++ 语言中，允许我们定义若干个具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。因为顶层 const 被忽略掉了，所以在上面代码中传入两个 `fcn` 函数的参数可以完全一样。因此第二个 `fcn` 是错误的，尽管形式上有差异，但实际上它的形参和第一个 `fcn` 的形参没什么不同。

**指针或引用形参与 const**

形参的初始化方式和变量的初始化方式是一样的：

```c++
int i = 42;
const int *cp = &i; // 正确：但是 cp 不能改变 i
const int &r = i;   // 正确，但是 r 不能改变 i
const int &r2 = 42; // 正确
int *p = cp;        // 错误：p 的类型和 cp 的类型不匹配
int &r3 = r;        // 错误：r3 的类型和 r 的类型不匹配
int &r4 = 42;       // 错误：不能用字面值初始化一个非常量引用
```

将同样的初始化规则应用到参数传递上来可得到如下形式：

```c++
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i);    // 调用形参类型是 int* 的 reset 函数
reset(&ci);   // 错误：不能用指向 const int 对象的指针初始化 int*
reset(i);     // 调用形参类型是 int 的 reset 函数
reset(ci);    // 错误：不能把普通引用绑定到 const 对象 ci 上
reset(42);    // 错误：不能把普通引用绑定到字面值上
reset(ctr);   // 错误：类型不匹配，ctr 是无符号类型
// 正确：find_char 的第一个形参是对常量的引用
find_char("Hello World!", '0', ctr);
```

要想调用引用版本的 `reset`，只能使用 int 类型的对象，而不能使用字面值、求值结果为 int 的表达式、需要转换的对象或者 const int 类型的对象。类似地，要想调用指针版本的 `reset` 只能使用 int*。

我们能传递一个字符串字面值作为 `find_char` 的第一个实参，这是因为该函数的引用形参是常量引用，而 C++ 允许我们用字面值初始化常量引用。

**尽量使用常量引用**

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质是：不允许拷贝数组以及使用数组时（通常）会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```c++
// 尽管形式不同，这三个 print 函数是等价的
// 每个函数都有一个 const int* 类型的形参
void print(const int*);
void print(const int[]);   // 可以看出，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际上不一定
```

当编译器处理对 `print` 函数的调用时，只检查传入的参数是否是 const int* 类型：

```c++
int i = 0, j[2] = { 0, 1 };
print(&i);  // 正确：&i 的类型是 int*
print(j);   // 正确：j 转换成 int* 并指向 j[0]
```

> 和使用其他数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。

因为数组是以指针的形式传递给函数，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术：

- **使用标记指定数组长度**

第一种技术要求数组本身包含一个结束标记。使用这种方法的典型示例是 C 风格字符串。C 风格的字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符：

```c++
void print(const char *cp) {
    if (cp) {               // 如果 cp 不是一个空指针
        while (*cp) {       // 只要指针所指的字符不是空字符
            cout << *cp++;  // 输出当前字符并将其指针向前移动一个位置
        }
    }
}
```

这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况。

- **使用标准库规范**

第二种技术是传递指向数组首元素和尾后元素的指针。使用该方法，我们可以按照如下形式输出元素内容：

```c++
void print(const int *beg, const int *end) {
    // 输出 beg 到 end 之间（不含 end）的所有元素
    whiile (beg != end) {
        cout << *beg++ << endl; // 输出当前元素并将其指针向前移动一个位置
    }
}
```

为了调用这个函数，我们需要传入两个指针：1）指向要输出的首元素；2）指向尾元素的下一个位置：

```c++
int j[2] = { 0, 1 };
print(begin(j), end(j)); // begin 和 end 函数
```

只要调用者能正确地计算指针所指的位置，那么上述代码就是安全的。

- **显示传递一个表示数组大小的形参**

第三种技术是专门定义一个表示数组大小的形参，在 C 程序和过去的 C++ 程序中常常使用这种方法。

```c++
// const int ia[] 等价于 const int* ia
// size 表示数组的大小，将它显示地传给函数用于控制对 ia 元素的访问
void print(const int ia[], sizt_t size) {
    for (sizt_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}
```

这个版本的程序通过形参 `size` 的值确定要输出多少个元素，调用 `print` 函数时必须传入这个表示数组大小的值：

```c++
int j[] = { 0, 1 };
print(j, end(j) - begin(j));
```

只要传递给函数的 `size` 值不超过数组实际的大小，函数就是安全的。

**数组形参和 const**

我们的三个 `print` 函数都把数组形参定义成了指向 const 的指针。当函数不需要对数组执行写操作时，数组形参应该是指向 const 的指针。只要当函数确实要改变元素值时，才把形参定义成指向非常量的指针。

**数组引用形参**

C++ 语言运行将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。引用形参绑定到对应的实参上，也就是绑定到数组上：

```c++
// 正确：形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
    for (auto elem : arr) {
        cout << elem << endl;
    }
}
```

> `&arr` 两端的括号必不可少：

```c++
f(int &arr[10])      // 错误：将 arr 声明成了引用的数组
f(int (&arr)[10])    // 正确：arr 是一个具有 10 个整数的整型数组的引用
```

因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了 `print` 函数的可用性，我们只能将函数作用于大小为 10 的数组：

```c++
int i = 0, j[2] = { 0, 1 };
int k[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
print(&i);   // 错误：实参不是含有 10 个整数的数组
print(j);    // 错误：实参不是含有 10 个整数的数组
print(k);    // 正确：实参是含有 10 个整数的数组
```

**传递多维数组**

和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为多维数组就是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面的所有维度）的大小都是数组类型的一部分，不能省略：

```c++
// matrix 指向数组的首元素，该数组的元素是由 10 个整数构成的数组
void print(int (*matrix)[10], int rowSize) {

}
```

> 再一次强调，`*matrix` 两端的括号必不可少：

```c++
int *matrix[10]       // 10 个指针构成的数组
int (*matrix)[10]     // 指向含有 10 个整数的数组的指针
```

我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内：

```c++
void print(int matrix[] [10], int rowSize) { /* */ }
```

`matrix` 的声明看起来是一个二维数组，实际上形参是指向含有 10 个整数的数组的指针。

### 6.2.5 main：处理命令行选项

假定 `main` 函数位于可执行文件 prog 之内，我们可以向程序传递下面的选项：

```
prog -d -o ofile data0
```

这些命令行选项通过两个（可选的）形参传递给 main 函数：

```c++
int main(int argc, char *argv[]) { ... }
```

第二个形参 `argv` 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 `argc` 表示数组中字符串的数量。因为第二个形参是数组，所以 `main` 函数也可以定义成：

```c++
int main(int argc, char **argv) { ... }
```

其中 `argv` 指向 char*。

当实参传给 `main` 函数之后，`argv` 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为 0。

以上面提供的命令行为例，`argc` 应该等于 5，`argv` 应该包含如下的 C 风格字符串：

```c++
argv[0] = "prog";     // 或者 argv[0] 也可以指向一个空字符串
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

> 当使用 `argv` 中的实参时，一定要记得可选的实参从 `argv[1]` 开始；`argv[0]` 保存程序的名字，而非用户输入。

### 6.2.6 含有可变形参的函数

为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：1）如果所有的实参类型相同，可以传递一个名为 initializer_list 的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。

C++ 还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与 C 函数交互的接口程序中。

**initializer_list 形参**

如果函数的实参数量未知，但是全部实参的类型都相同，我们可以使用 initializer_list 类型的形参。initializer_list 是一种标准库类型，用于表示某种特定类型的值的数组。它提供的操作如下：

``` c++
// 默认初始化
initializer_list<T> lst;

// lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const
initializer_list<T> lst{ a, b, c };

// 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素
lst2(lst)
lst2 = lst

// 列表中的元素数量
lst.size()

// 返回指向 lst 中首元素的指针
lst.begin()

// 返回指向 lst 中尾元素下一位置的指针
lst.end()
```

和 vector 一样，initializer_list 也是一种模板类型。定义 initializer_list 对象时，必须说明列表中所含元素的类型：

```c++
initializer_list<string> ls;   // 元素类型是 string
initializer_list<int> li;      // 元素类型是 int
```

和 vector 不一样的是，initializer_list 对象中的元素永远是常量值，我们无法改变 initializer_list 对象中元素的值。

我们使用如下的形式编写输出错误信息的函数，使其可以作用于可变数量的实参：

```c++
void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg) {
        cout << *beg << " ";
    }
    cout << endl;
}
```

如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内：

```c++
// expected 和 actual 是 string 对象
if (expected != actual) {
    error_msg({ "functionX", expected, actual })
} else {
    error_msg({ "functionX", "okay" })
}
```

含有 initializer_list 形参的函数也可以同时拥有其他形参：

```c++
void error_msg(ErrCode e, initializer_list<string> il) {
    cout << e.msg() << ": ";
    for (const auto &elem : il) {
        cout << elem << " ";
    }
    cout << endl;
}
```

调用：


```c++
// expected 和 actual 是 string 对象
if (expected != actual) {
    error_msg(ErrCode(42), { "functionX", expected, actual })
} else {
    error_msg(ErrCode(0), { "functionX", "okay" })
}
```

**省略符形参**

省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的。

> 省略符形参应该仅仅用于 C 和 C++ 通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎两种：

```c++
void foo(parm_list, ...);
void foo(...);
```

在第一种形式中，形参声明后面的逗号是可选的。

## 6.3 返回类型和 return 语句

return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return 语句有两种形式：

```c++
return;
return expression;
```

### 6.3.1 无返回值函数

没有返回值的 return 语句只能用在返回类型是 void 的函数中。返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式地执行 return。

通常情况下，void 函数如果想在它的中间位置提前退出，可以使用 return 语句：

```c++
void swap(int &v1, int &v2) {
    // 如果两个值是相等的，则不需要交换，直接退出
    if (v1 == v2) {
        return;
    }
    // 如果程序执行到这里，说明还需要继续完成某些功能
    int tmp = v2;
    v2 = v1;
    v1 = tmp;
    // 此处无需显示的 return 语句
}
```

一个返回类型是 void 的函数也能使用 return 语句的第二种形式，不过此时 return 语句的 expression 必须是另一个返回 void 的函数。

### 6.3.2 有返回值函数

只要函数的返回类型不是 void，则该函数内的每一条 return 语句必须返回一个值。return 语句返回值的类型必须与函数的返回类型相同。

例子：

```c++
// 因为含有不正确的返回值，所以这段代码无法通过编译
bool str_subrange(const string &str1, const string &str2) {
    // 大小相同：此时用普通的相等性判断结果作为返回值
    if (str1.size() == str2.size()) {
        return str1 == str2; // 正确： == 运算符返回布尔值
    }

    // 得到较短 string 对象的大小
    auto size = (str1.size() < str2.size()) ? str1.size() : str2.size();

    // 检查两个 string 对象的对应字符是否相等，以较短的字符串长度为限
    for (decltype(size) i = 0; i != size; ++i) {
        if (str1[i] != str2[i]) {
            return;   // 错误 #1：没有返回值，编译器将报告这一错误
        }
    }
    // 错误 #2：控制流可能尚未返回任何值就结束了函数的执行
    // 编译器可能检查不出这一错误
}
```

for 循环内的 return 语句是错误的，因为它没有返回值，编译器检测到这个错误。第二个错误是函数在 for 循环之后没有提供 return 语句。

> 在含有 return 语句的循环后面应该也有一条 return 语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。

**值是如何被返回的**

返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时变量，该临时变量就是函数调用的结果。

必须注意当函数返回局部变量时的初始化规则。例如写一个函数返回单词的复数形式：

```c++
string make_plural(sizt_t ctr, const string &word, const string &ending) {
    return (ctr > 1) ? word + ending : word;
}
```

该函数的返回值是 string，意味着返回值将被拷贝到调用点。因此，该函数将返回 `word` 的副本或一个未命名的临时 string 对象，该对象的内容是 `word` 和 `ending` 的和。

如果函数返回引用，则该引用仅是它所引对象的一个别名。例如：假设某函数挑出两个 string 形参中较短的那个并返回其引用：

```c++
const string &shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

其中形参和返回值都是 const string 的引用，不管是调用函数还是返回结果都不会真正拷贝 string 对象。

**不要返回局部对象的引用或指针**

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```c++
// 严重错误：这个函数试图返回局部对象的引用
const string &manip() {
    string ret;
    if (!ret.empty()) {
        return ret;      // 错误：返回局部对象的引用
    } else {
        return "Empty";  // 错误："Empty" 是一个局部临时变量
    }
}
```

上面的两条 return 语句都将返回未定义的值。

> 要想确保返回至安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象？

**返回类类型的函数和调用运算符**

调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数的调用结果访问结果对象的成员。

例如：

```c++
// 调用 string 对象的 size 成员，该 string 对象是由 shorterString 返回的
auto sz = shorterString(s1, s2).size();
```

**引用返回左值**

函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值：

```c++
char &get_val(string &str, string::size_type ix) {
    return str[ix];   // get_val 假定索引值是有效的
}

int main() {
    string s("a value");
    cout << s << endl;       // 输出 a value
    get_value(s, 0) = 'A';   // 将 s[0] 的值改为 A
    cout << s << endl;       // 输出 A value
    return 0;
}
```

把函数调用放在赋值语句的左侧看起来有点奇怪，但其实没什么特别。返回值是引用，因此调用是个左值，和其他左值一样它也能出现在赋值运算符的左侧。

如果返回值是常量引用，我们不能给调用的结果赋值。

**列表初始化返回值**

C++11 新标准规定，函数可以返回花括号包围的值得列表。此列表用来对表示函数返回的临时变量进行初始化。如果列表为空，临时变量执行值初始化；否则，返回的值由函数的返回类型决定。

在下面的函数中，我们用一个 vector 对象，用它存放表示错误信息的 string 对象：

```c++
vector<string> process() {
    if (expected.empty()) {
        return { };                     // 返回一个空 vector 对象
    } else if (expected == actual) {
        return { "functionX", "okay" }; // 返回列表初始化的 vector 对象
    } else {
        return { "functionX", expected, actual };
    }
}
```

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，有类本身定义初始值如何使用。

**主函数 main 的返回值**

之前介绍过，如果函数的返回类型不是 void，那么它必须返回一个值。但是这条规则有个例外：我们允许 `main` 函数没有 return 语句直接结束。如果控制到达了 `main` 函数的结尾处而且还没有 return 语句，编译器将隐式地插入一条返回 0 的 return 语句。

`main` 函数的返回值可以看做是状态指示器：返回 0 表示执行成功，返回其他值表示执行失败，其中非 0 值的具体含义依机器而定。为了使返回值与机器无关，cstdlib 头文件定义了两个预处理变量，分别表示成功和失败：

```c++
int main() {
    if (some_failure) {
        return EXIT_FAILURE;      // 定义在 cstdlib 头文件中
    } else {
        return EXIT_SUCCESS;      // 定义在 cstdlib 头文件中
    }
}
```

因为它们是预处理变量，所以既不能在前面加上 `std::`，也不能在 `using` 声明中出现。

**递归**

如果一个函数调用了它自身，不管这种调用是直接还是间接的，都称该函数为递归函数。

例如，我们使用递归函数重新实现求阶乘的功能：

```c++
int factorial(int val) {
    if (val > 1) {
        return factorial(val - 1) * val;
    }
    return 1;
}
```

在递归调用中，一定有某条路径是不包含递归调用的；否则函数将“永远”递归下去，换句话说，函数将不断调用它自身直到程序栈空间耗尽为止。我们有时候会说这种函数含有**递归循环**。在 `factorial` 函数中，递归终止条件是 `val` 等于 `1`。

> main 函数不能调用它自己。

### 6.3.3 返回数组指针

因为数组不能拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。

从语法上，要想定义一个返回数组的指针或引用的函数比较麻烦，我们可以使用类型别名来简化这一任务：

```c++
typedef int arrT[10];  // arrT 是一个类型别名，表示的类型是含有 10 个整数的数组
using arrT = int[10];  // arrT 的等价声明
arrT* func(int i);     // func 返回一个指向含有 10 个整数的数组的指针
```

**声明一个返回数组指针的函数**

要想在声明 `func` 时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：

```c++
int arr[10];           // arr 是一个含有 10 个整数的数组
int *p1[10];           // p1 是一个含有 10 个指针的数组
int (*p2)[10] = &arr;  // p2 是一个指针，它指向含有 10 个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。函数的形参列表也跟在函数名字后面而且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下：

```
Type (*function(parameter_list)) [dimension]
```

*Type* 表示元素的类型，*dimension* 表示数组的大小。`(*funciton(parameter_list))` 两端的括号必须存在，就像我们定义 `p2` 时两端必须有括号一样。如果没有括号，函数返回的类型将是指针的数组。

下面这个 `func` 函数的声明没有使用类型别名：

```c++
int (*func(int i))[10];
```

理解该声明的含义：

- `func(int i)` 表示调用 `func` 函数时需要一个 int 类型的实参。
- `(*func(int i))` 意味着我们可以对函数调用的结果执行解引用操作。
- `(*func(int i))[10]` 表示解引用 `func` 的调用将得到一个大小是 10 的数组。
- `int (*func(int i))[10]` 表示数组中的元素是 int 类型。

**使用尾置返回类型**

在 C++11 新标准中还有一种可以简化上述 `func` 声明的方法，就是使用**尾置返回类型**。任何函数的定义都能使用尾置返回。尾置返回类型跟在形参列表后面并以一个 `->` 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们需要在本应该出现返回类型的地方防止一个 auto：

```c++
// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组
auto func(int i) -> int(*)[10];
```

**使用 decltype**

如果我们知道函数返回的指针指向哪个数组，就可以使用 decltype 关键字声明返回类型。

例如：

```c++
int odd[] = { 1, 3, 5, 7, 9 };
int even[] = { 0, 2, 4, 6, 8 };
// 返回一个指针，该指针指向含有 5 个整数的数组
decltype(odd) *arrPtr(int i) {
    return (i % 2) ? &odd : &even; // 返回一个指向数组的指针
}
```

decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示 `arrPtr` 返回指针还必须在函数声明时加一个 `*` 符号。

## 6.4 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。例如，之前定义的几个名为 `print` 的函数：

```c++
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

这些函数接收的形参类型不一样，但是执行的操作非常类似。调用时，编译器会根据传递的实参类型推断出想要的是哪个函数：

```c++
int j[2] = { 0, 1 };
print("Hello World");        // 调用 print(const char *cp)
print(j, end(j) - begin(j)); // 调用 print(const int ia[], size_t size)
print(begin(j), end(j));     // 调用 print(const int *beg, const int *end)
```

> `main` 函数不能重载。

**定义重载函数**

对于重载函数来说，它们应该在形参数量或形参类型上有所不同。

不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的：

```c++
Record lookup(const Account&);
bool lookup(const Account&);    // 错误：遇上一个函数相比只有返回类型不同
```

**判断两个形参的类型是否相异**

有时候两个形参列表看起来不一样，但实际上是相同的：

```c++
// 每对声明的都是同一个函数
Record lookup(const Account &acct);
Record lookup(const Account&);       // 省略了形参的名字

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&);   // Telno 和 Phone 的类型相同
```

第一对声明中，第一个函数给它的形参起了名字，第二个函数没有。形参的名字仅仅起到帮助记忆作用，有没有它并不影响形参列表的内容。

第二对声明看起来不同，但事实上 Telno 不是一种新类型，它只是 Phone 的别名。

**重载和 const 形参**

顶层 const 不影响传入函数的对象：

```c++
Record lookup(Phone);
Record lookup(const Phone); // 重复声明了 Record lookup(Phone)

Record lookup(Phone*);
Record lookup(Phone* const); // 重复声明了 Record lookup(Phone*)
```

在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。

如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的：

```c++
Record lookup(Account&);       // 函数作用于 Account 的引用
Record lookup(const Account&); // 新函数，作用于常量引用

Record lookup(Account*);       // 新函数，作用于指向 Account 的指针
Record lookup(const Account*); // 新函数，作用于指向常量的指针
```

上面的例子中，编译器可以通过实参是否是常量来推断出应该调用哪个函数。因为 const 不能转换成其他类型，所以我们只能把 const 对象（或指向 const 的指针）传递给 const 形参。相反的，因为非常量可以转换成 const，所以上面的 4 个函数都能作用于非常量对象或者指向非常量的指针。但是，当我们传递一个非常量对象或者指向非常量的指针时，编译器会优先选用非常量版本的函数。

**const_cast 和重载**

const_cast 在重载函数的情景中最有用。

下面是之前的 `shorterString` 函数：

```c++
// 比较两个 string 对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2) {
    return s1.size() < s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是 const string 的引用。但是现在我们想要一个新的 `shorterString` 函数，实参不是常量，并且得到的结果是普通的引用。使用 const_cast 就可以实现：

```c++
string &shorterString(string &s1, string &s2) {
    auto &r = shorterString(const_cast<const string&>(s1),
                            const_cast<const string&>(s2));
    return const_cast<string&>(r);    
}
```

新的函数中利用 const_cast 调用 `shorterString` 函数的 const 版本。const 版本返回了对 const string 的引用，这个引用事实上绑定了在某个初始的非常量实参上。因此，我们可以在将其转换回一个普通的 string&，这显然是安全的。

**调用重载的函数**

**函数匹配**是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做**重载确定**。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

当调用重载函数时有三种可能的结果：

- 编译器找到一个与实参**最佳匹配**的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，笔试编译器发出**无匹配**的错误信息。
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用**（ambiguous call）。

### 6.4.1 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同作用域中无法重载函数名：

```c++
string read();
void print(const string &s);
void print(double);
void fooBar(int ival) {
    bool read = false;    // 新作用域：隐藏了外层的 read
    string s = read();    // 错误：read 是一个布尔值，而非函数
    // 不好的习惯：通常来说，在局部作用域中声明函数不是一个好的选择
    void print(int);      // 新作用域，隐藏了之前的 print
    print("Value: ")      // 错误：print(const string &) 被隐藏掉了
    print(ival);          // 正确：当前 print(int) 可见
    print(3.14);          // 正确：调用 print(int); print(double) 被隐藏掉了
}
```

> 在 C++ 语言中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，我们把这个反复出现的值称为函数的**默认实参**。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

例如：

```c++
typedef string::size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = '');
```

我们可以为一个或多个形参定义默认值，不过要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

**使用默认实参调用函数**

如果想使用默认实参，只要在调用函数的时候省略该实参就可以了：

```c++
string window;
window = screen();               // 等价于 screen(24, 80, '')
window = screen(66);             // 等价于 screen(66, 80, '')
window = screen(66, 256);        // 等价于 screen(66, 256, '')
window = screen(66, 256, '#');   // 等价于 screen(66, 256, '#')
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。例如，要想覆盖 `backgrnd` 的默认值，必须为 `ht` 和 `wid` 提供实参：

```c++
window = screen(, , '?');     // 错误：只能省略尾部的实参
window = screen('?');         // 调用 screen('?', 80, ' ')
```

第二个调用传递一个字符值，是合法的调用，但是与书写意图不符。之所以合法是因为 `'?'` 是一个 char，而函数最左侧的类型 string::size_type 是一种无符号整数类型，所以 char 类型可以转换成函数最左侧形参的类型。

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

**默认实参声明**

对于函数声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。但是，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

假如给定：

```c++
string screen(sz, sz, char = '');
```

我们不能修改一个已经存在的默认值：

```c++
string screen(sz, sz, char = '*');      // 错误：重复声明
```

但是可以按照如下形式添加默认实参：

```c++
string screen(sz = 24, sz = 80, char);  //  正确：添加默认实参
```

> 通常，应该在函数声明中指定默认实参，并将该声明放在何时的头文件中。

**默认实参初始值**

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```c++
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);

string window = screen();  // 调用 screen(ht(), 80, ' ')
```

用作默认实参的名字在函数声明的作用域内解析，而这些名字的求值过程发生在函数调用时：

```c++
void f2 {
    def = '*';           // 改变默认实参的值
    sz wd = 100;         // 隐藏了外层定义的 wd，但是没有改变默认值
    window = screen();   // 调用 screen(ht(), 80, '*')
}
```

### 6.5.2 内联函数和 constexpr 函数

在之前的章节中，我们编写了一个小函数，它的功能是比较两个 string 形参的长度并返回长度较小的 string 的引用。把这种规模较小的操作定义成函数有很多好处，主要包括：

- 阅读和理解 `shorterSting` 函数的调用要比读懂等价的条件表达式容易得多。
- 使用函数可以确保行为的统一，每次相关操作都能保证按照同样的方式进行。
- 如果我们需要修改计算的过程，显然修改函数要比先找到等价表达式所有出现的地方再逐一修改更容易。
- 函数可以被其他应用重复利用，省去了程序员重新编写的代价。

然而，使用 `shorterString` 函数也存在一个潜在的缺点：调用函数一般比求等价表达式的值要慢一些。

**内联函数可避免函数调用的开销**

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。

假设我们把 `shorterString` 函数定义成内联函数，则如下调用

```c++
cout << shorterString(s1, s2) << endl;
```

将在编译过程中展开类似于下面的形式

```c++
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了 `shorterString` 函数的运行时开销。

在 `shorterString` 函数的返回类型前面加上关键字 inline 就可以声明为内联函数：

```c++
inline const string&
shorterString(const string &s1, const string &s2) {
    return s1.size() < s2.size() ? s1 : s2;
}
```

> 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

**constexpr 函数**

constexpr 函数是指能用于常量表达式的函数。定义 constexpr 函数需要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须只有一条 return 语句：

```c++
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();   // 正确：foo 是一个常量表达式
```

我们把 `new_sz` 定义成无参数的 constexpr 函数。因为编译器能在程序编译时验证 `new_sz` 函数返回的是常量表达式，所以可以用 `new_sz` 函数初始化 constexpr 类型的变量 `foo`。

执行该初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。

constexpr 函数体内可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如空语句、类型别名以及 using 声明。

允许 constexpr 函数的返回值并非一个常量：

```c++
// 如果 arg 是常量表达式，则 scale(arg) 也是常量表达式
constexpr size_t scale(size_t cnt) {
    return new_sz() *cnt;
}
```

当 scale 的实参是常量表达式时，它的返回值也是常量表达式；反之则不然：

```c++
int arr[scale[2]];     // 正确：scale(2) 是常量表达式
int i = 2;             // i 不是常量表达式
int a2[scale(i)];      // 错误：scale(i) 不是常量表达式
```

> constexpr 函数不一定返回常量表达式。

**把内联函数和 constexpr 函数放在头文件内**

和其他函数不一样，内联函数和 constexpr 函数可以在程序中多次定义。毕竟，编译器想要展开函数仅有函数声明时不够的，还需要函数的定义。不过，对于某个给定的内联函数或者 constexpr 函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和 constexpr 函数通常定义在头文件中。

### 6.5.3 调试帮助

**assert 预处理宏**

**assert** 是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似内联函数。assert 宏使用一个表达式作为它的条件：

```c++
assert(expr);
```

首先对 `expr` 求值，如果表达式为假（即 `0`），assert 输出信息并终止程序的执行。如果表达式为真（即非 `0`），assert 什么也不做。

assert 宏定义在 cassert 头文件中。因为预处理名字由预处理而非编译器管理，所以我们可以直接使用预处理名字而无需提供 using 声明。也就是应该使用 assert 而不是 `std::assert`，也不需要为 assert 提供 using 声明。

**NDEBUG 预处理变量**

assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 将执行运行时检查。

可以使用一个 `#define` 语句定义 NDEBUG，从而关闭调试状态。

除了用于 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 `#ifndef` 和 `#endif` 之间的代码；如果定义了 NDEBUG，这些代码将忽略掉：

```c++
void print(const int ia[], size_t size) {
    #ifndef NDEBUG
    // __func__ 是编译器定义的一个局部静态变量，用于存放函数的名字
    cerr << __func__ << ": array size is " << size << endl;
    #endif
}
```

变量 `__func__` 是当前函数的名字。编译器为每个函数都定义了 `__func__`，他是 const char 的一个静态数组，用于存放函数的名字。

预处理器还定义了其他名字：

- `__FILE__` 存放文件名的字符串字面值。
- `__LINE__` 存放当前行号的整型字面值。
- `__TIME__` 存放文件编译时间的字符串字面值。
- `__DATE__` 存放文件编译日期的字符串字面值。

## 6.6 函数匹配

在多数情况下，我们容易确定某次调用应该选用哪个重载函数。但是当重载函数的形参数量相等以及某些形参的类型可以由其他类型转换得来时，就没那么容易了。以下面这组函数为例：

```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);   // 调用 void f(double, double)
```

**确定候选函数和可行函数**

函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为**候选函数**。候选函数具备两个特征：1）与被调用的函数同名；2）其声明在调用点可见。

第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，选出的函数称为**可行函数**。可行函数具有两个特征：1）其形参数量与本次调用提供的实参数量相等；2）每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

上面的调用例子 `f(5.6)` 中，根据以上的原则，可以得出：

```c++
// 排除掉，形参的数量与调用实参不相等
void f();
void f(int, int);

// 下面两个都能调用，符合规则，都是可行函数
// 因为实参类型 double 能转换成形参类型 int
void f(int);                    
// 因为第二个形参提供了默认值，第一个形参正好是 double 类型，与函数使用的实参类型完全一致
void f(double, double = 3.14);  
```

> 如果没找到可行的函数，编译器将报告无匹配函数的错误。

**寻找最佳匹配（如果有的话）**

函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。它的基本思想是：实参类型与形参类型越接近，它们匹配得越好。

在这个例子中，`f(5.6)` 只提供了一个实参，它的类型是 double。如果调用 `f(int)`，实参不得不从 double 转换成 int。而另一个函数 `f(double, double)` 则与实参精确匹配。因此，编译器把 `f(5.6)` 解析成对含有两个 double 形参的函数的调用。

**含有多个形参的函数匹配**

当实参的数量有两个或更多时，函数匹配就比较复杂了。对于前面名为 `f` 的函数，来分下如下调用：

```c++
(42, 2.56);
```

首先选出可行函数如下：

```c++
void f(int, int);
void f(double, double = 3.14);  
```

接下来看哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：

- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。
- 至少有一个实参的匹配优于其他可行函数提供的匹配。

如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用。

上面的两个可行函数中，每个函数各自在一个实参上实现了更好的匹配，从整体上无法判断孰优孰劣。所以编译器将报告二义性调用。看起来我们似乎可以通过强制类型转换其中一个实参来实现函数匹配，但是在设计良好的系统中，不应该对实参进行强制类型转换。

> 调用重载函数时，应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下：

1. 精确匹配，包括以下情况：
- 实参类型和形参类型相同。
- 实参从数组类型或函数类型转换成对应的指针类型。
- 向实参添加顶层 const 或者从实参中删除顶层 const。
2. 通过 const 转换实现的匹配
3. 通过类型提升实现的匹配
4. 通过算术类型转换或指针转换实现的匹配

**需要类型提升和算术类型转换的匹配**

> 内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但在设计良好的系统中函数很少会含有与下面例子类似的形参。

分析函数前，我们应该知道小整型一般都会提升到 int 类型或者更大的整数类型。

例子：

```c++
void ff(int);
void ff(short);
ff('a');        // char 提升成 int；调用 f(int)
```

只有当调用提供的是 short 类型的值时才会选择 short 版本的函数。

所有算术类型转换的级别都一样。例如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高。例如：

```c++
void manip(long);
void manip(float);
manip(3.14);         // 错误：二义性调用
```

字面值 `3.14` 的类型是 double，它既可转换成 long 也能转换成 float。因为存在两种可能的算术类型转换，所以该调用具有二义性。

**函数匹配和 const 实参**

如果重载函数的区别在于它们的引用类型实参是否引用了 const，或者指针类型的形参是否指向 const，则调用时编译器通过实参是否是常量来决定选择哪个函数：

```c++
Record looup(Account&);        // 参数是普通引用
Record looup(const Account&);  // 参数是常量引用
const Account a;
Account b;

lookup(a);                     // 调用 Record looup(const Account&)
lookup(b);                     // 调用 Record looup(Account&)
```

第一个调用中，传入的是 const 对象 `a`。因为不能把普通引用绑定到 const 对象上，所以唯一可行的函数是 `Record looup(const Account&)`，并且与实参 `a` 精确匹配。

第二个调用中，传入的是非常量对象 `b`。对于这个调用，两个函数都是可行的，因为可以使用 `b` 初始化常量引用也可以用它来初始化非常量引用。但是用非常量对象初始化常量引用需要类型转换，然而 `Record looup(Account&)` 可以精确匹配，所以应该选用非常量版本的函数。

指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参指向常量和非常量，则编译器通过实参是否是常量决定选用哪个函数：如果实参是指向常量指针，调用形参是 `const *` 的函数；如果实参是指向非常量指针，调用形参是普通指针的函数。

## 6.7 函数指针

函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：

```c++
bool lengthCompare(const string&, const string&);
```

该函数的类型是 `bool (const string&, const string&)`。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```c++
// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool 类型
bool (*pf)(const string&, const string&); // 未初始化
```

> `*pf` 两端的括号必不可少。如果不写这个括号，则 `pf` 是一个返回值为 bool 指针的函数。

**使用函数指针**

当把函数名作为一个值使用时，该函数自动转换成指针。例如：

```c++
pf = lengthCompare;    // pf 指向名为 lengthCompare 的函数
pf = &lengthCompare;   // 等价于赋值语句：取址符是可选的
```

可以直接使用指向函数的指针调用该函数，无须提前解引用指针：

```c++
bool b1 = pf("hello", "goodbye");       // 调用 lengthCompare 函数
bool b2 = (*pf)("hello", "goodbye");    // 一个等价的调用
bool b3 = lengthCompare("hello", "goodbye");  // 令一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是我们可以为函数指针赋一个 `nullptr` 或者值为 `0` 的整型常量表达式。表示该指针没有指向任何一个函数。

```c++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0;                // 正确：pf 不指向任何函数
pf = sumLength;        // 错误：返回类型不匹配
pf = cstringCompare;   // 错误：形参类型不匹配
pf = lengthCompare;    // 正确：函数和指针的类型精确匹配
```

**重载函数的指针**

当使用重载函数时，上下文必须清晰地界定应该选用哪个函数。如果定义了指向重载函数的指针：

```c++
void ff(int *);
void ff(unsigned int);

void (*pf1) (unsigned int) = ff;    // pf1 指向 ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配：

```c++
void (*pf2) (int) = ff;     // 错误：没有任何一个 ff 与该形参列表匹配
double (*pf3) (int*) = ff;  // 错误：ff 和 pf3 的返回类型不匹配
```

**函数指针形参**

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。

```c++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2,
                bool pf(const string&, const string&));

// 等价声明：显式地将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2,
                bool (*pf)(const string&, const string&));
```

我们可以直接把函数当做实参使用，此时它会自动转换成指针：

```c++
useBigger(s1, s2, lengthCompare);
```

类型别名和 decltype 可以简化函数指针的代码：

```c++
// Func 和 Func2 是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2;   // 等价的类型

// FuncP 和 FuncP2 是指向函数的指针
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2;   // 等价的类型
```

可以使用如下形式重新声明 `useBigger`：

```c++
// useBigger 的等价声明，其中使用了类型别名
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```

这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动将 `Func` 表示的函数类型转换成指针。

**返回指向函数的指针**

必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```c++
using F = int(int*, int);        // F 是函数类型，不是指针
using PF = int(*)(int*, int);    // PF 是指针类型
```

必须显式地将返回类型指定为指针：

```c++
PF f1(int);   // 正确：PF 是指向函数的指针，f1 返回指向函数的指针
F f1(int);    // 错误：F 是函数类型，f1 不能返回一个函数
F *f1(int);   // 正确：显式地指定返回类型是指向函数的指针
```

当然，也能直接用下面的形式直接声明 `f1`：

```c++
int (*f1(int))(int*, int);
```

我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数：

```c++
auto f1(int) -> int (*)(int*, int);
```

**将 auto 和 decltype 用于函数指针类型**

如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程。

例如假定有两个函数，它们的返回类型都是 string::size_type，并且各有两个 const string& 类型的形参，此时我们可以编写第三个函数，它接受一个 string 类型的参数，返回一个指针，该指针指向前两个函数中的一个：

```c++
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);

// 根据其形参的取值，getFcn 函数返回指向上面两个函数之一的指针
decltype(sumLength) *getFun(const string&);
```

decltype 作用于某个函数时，它返回函数类型而非指针类型。因此，需要显式地加上 `*` 表明我们需要返回指针，而非函数本身。
