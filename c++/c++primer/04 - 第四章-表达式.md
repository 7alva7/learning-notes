## 4.1 基础

### 4.1.1 基本概念

C++ 定义了 **一元运算符**和**二元运算符**。作用于一个运算对象的是一元运算符，如取地址符（`&`）和解引用符（`*`）。作用于两个运算对象的是二元运算符，如相等运算符（`==`）和乘法运算符（`*`）。还有一种作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

### 4.1.2  优先级与结合律

**复合表达式**是指含有两个或多个运算符的表达式。

### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。

```c++
int i = 0;
cout << i << " " << ++i << endl;    // 未定义的
```

因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求出 `++i` 的值，此时输出结果为 `1 1`，也有可能先求 `i` 的值再求 `++i` 的值，输出结果为 `0 1`。甚至编译器还可能做完全不同的操作，因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

有 4 种运算符明确规定了运算符的求值顺序：1）逻辑与运算符（`&&`），它规定先求左侧运算对象的值为真时才继续求左侧运算对象的值；2）逻辑或运算符（`||`）；3）条件运算符（`?:`）；4）逗号运算符（`,`）。

**求职顺序、优先级、结合律**

运算对象的求值顺序与优先级和结合律无关，在一条形如 `f() + g() * h() + j()` 的表达式中：

- 优先级规定，`g()` 的返回值和 `h()` 的返回值相乘。
- 结合律规定，`f()` 的返回值先与 `g()` 和 `h()` 的乘积相加，所得的结果再与 `j()` 的返回值相加。
- 对于这些函数的调用顺序没有明确的规定。

如果 `f`、`g`、`h` 和 `j` 是无关函数，它们既不会改变同一对象的状态也不会执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它们是一条错误的表达式，将产生未定义的行为。

**建议：处理复合表达式**

- 1. 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
- 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。

第二条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算 对象时，该规则无效。例如，在表达式 `*++iter` 中，递增运算符改变 `iter` 的值，`iter`（已经改变）的值又是解引用运算符的运算对象。此时，求值的顺序不会成为问题。因为递增运算符（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。显然，这是一种很常见的用法，不会造成什么问题。

## 4.2 算术运算符

| 运算符 | 功能 | 用法 |
| :------: | :------: | :------: |
| + | 一元正号 | + expr |
| - | 一元负号 | - expr |
| * | 乘法 | expr * expr |
| / | 除法 | expr / expr |
| % | 求余 | expr % expr |
| + | 加法 | expr + expr |
| - | 减法 | expr - expr |

表格的运算符中，一元运算符的优先级最高，其次是乘法和除法，最低的是加法和减法。上面的所有运算符都满足左结合律，意味着当优先级相同时按照从左向右的顺序进行组合。

一元正号运算符、加法运算符和减法运算符都能作用于指针。当一元正号运算符作用于与一个指针或者算数值时，返回算数值时，返回运算对象值的一个（提升后的）副本。

一元负号运算符对运算对象取负后，返回其（提升后的）副本：

```c++
int i = 1024;
int k = -i;        // k 是 -1024
bool b = true;
bool b2 = -b;      // b2 是 true （布尔值不参与运算）
```

对大多数运算符来说，布尔类型的运算对象将被提升为 `int` 类型。如上所示，`b` 的值为真，参与运算时将被提升为整数值 `1`，对它求负的结果是 `-1`。再转换回布尔值并将其作为 `b2` 的初始值，显然这个初始值不等于 `0`，转换成布尔值后应该为 `1`。所以，`b2` 的值是真。

当作用于算术类型的对象时，算术运算符 `+`、`-`、`*` 和 `/` 的含义分别为加法、减法、乘法、除法。整数相除结果还是整数，也就是说，如果商好友小数部分，直接去掉：

```c++
int ival1 = 21 / 6;  // ival1 是 3，余数被去掉
int ival2 = 21 / 7;  // ival2 是 3，没有余数，结果是整数值
```

运算符 `%` 俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数，彩玉取余运算的运算对象必须是整数类型：

```c++
int ival = 42;
double dval = 3.14;
ival % 12;           // 正确：结果是 6
ival % dval;         // 错误：运算对象是浮点型
```

在除法运算中，如果两个运算对象的符号相同则商为正，否则为负。C++ 语言早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向 0 取整（即直接切除小数部分）。

## 4.3 逻辑和关系运算符

|结合律| 运算符 | 功能 | 用法 |
| :------: | :------: | :------: | :------: |
|左| ! | 逻辑非 | !expr |
|左| < | 小于 | expr < expr |
|左| <= | 小于等于 | expr <= expr |
|左| > | 大于 | expr > expr |
|左| >= | 大于等于 | expr >= expr |
|左| == | 相等 | expr == expr |
|左| != | 不相等 | expr != expr |
|左| && | 逻辑与 | expr && expr |
|左| `||` | 逻辑或 | `expr || expr` |

对于逻辑与运算符（`&&`）来说，当且仅当两个运算对象都为真时结果为真；对于逻辑或运算符（`||`）来说，只要两个运算对象中的一个为真结果就为真。

逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为**短路求值**。

- 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。
- 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。

**相等性测试与布尔字面值**

进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值 `true` 和 `false` 作为运算对象。

## 4.4 赋值运算符

**赋值运算符满足右结合律**

```c++
int ival, jval;
ival = jval = 0;   // 正确：都被赋值为 0
```

因为赋值运算符满足右结合律，所以靠右的赋值运算 `jval = 0` 作为靠左的赋值运算符的右侧运算对象。又因为赋值运算符返回其左侧运算对象，所以靠右的赋值运算符的结果（`jval`）被赋给了 `ival`。

**赋值运算优先级较低**

```c++
int i;
while ((i = get_value()) != 42) {
    // 其他处理
}
```

如果 `i = get_value()` 不加括号的话含义会有很大的变化，比较运算符 `!=` 的运算对象是 `get_value` 函数的返回值及 `42`，比较的结果不论真假将以布尔值的形式赋值给 `i`，这显然不是我们期望的结果。

> 因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。

## 4.5 递增和递减运算符

递增和递减运算符有两种形式：前置版本和后置版本。前置版本首先将运算对象加 `1`（或减 `1`），然后将改变后的对象作为求值结果。后置版本也会将运算对象加 `1`（或减 `1`），但是求值结果是运算对象改变之前的那个值得副本。

```c++
int i = 0, j;
j = ++i;        // j = 1, i = 1: 前置版本得到递增之后的值
j = i++;        // j = 1, i = 2: 后置版本得到递增之前的值
```

这两种运算符必须作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。

> 建议：除非必须，否则不用递增递减运算符的后置版本。

**在一条语句中混用解引用和递增运算符**

如果我们想在一条复合表达式中即将变量加 `1` 或减 `1` 又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。

```c++
auto pbeg = v.begin();
while (pbeg != v.end() && *pbeg >= 0) {
    cout << *pbeg++ << endl;
}
```

后置递增运算符优先级高于解引用运算符，因此 `*pbeg++` 等价于 `*(pbeg++)`。`pbeg++` 把 `pbeg` 的值加 `1`，然后返回 `pbeg` 的初始值的副本作为其求值结果，此时解引用运算符的运算对象是 `pbeg` 未增加之前的值。最终，这条语句输出 `pbeg` 开始时指向的那个元素，并将指针向前移动一个位置。

## 4.6 成员访问运算符

点运算符和箭头运算符都可用于访问成员。点运算符获取类对象的成员；箭头运算符与点运算符有关，表达式 `ptr->mem` 等价于 `(*ptr).mem`：

```c++
string s1 = "a string", *p = &s1;
auto n = s1.size();    // 运行 string 对象的 size 成员
n = (*p).size();       // 运行 p 所指对象的 size 成员
n = p->size();         // 等价于 (*p).size()
```

因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没有括号，代码的含义就大不相同了：

```c++
// 运行 p 的 size 成员，然后解引用 size 的结果
*p.size();    // 错误： p 是一个指针，它没有名为 size 的成员
```

## 4.7 条件运算符

条件运算符（`?:`）允许我们把简单的 `if-else` 逻辑嵌入到单个表达是中，形式如下：

```
cond ? expr1 : expr2;
```

其中 `cond` 是判断条件的表达式，而 `expr1` 和 `expr2` 是两个类型相同或可能转为某个公共类型的表达式。执行的过程是：首先球 `cond` 的值，如果条件为真对 `expr1` 求值并返回该值，否则对 `expr2` 求值并返回该值。例如使用条件运算符判断成绩是否合格：

```c++
string finalgrade = (grade < 60) ? "fail" : "pass";
```

**嵌套条件运算符**

```c++
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```

> 随着条件运算符嵌套层数的增加，代码的可读性急剧下降。因此，条件运算符的嵌套最好别超过两到三层。

**在输出表达式中使用条件运算符**

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件子表达式时，通常需要在它两端加上括号。例如：

```c++
cout << ((grade < 60) ? "fail" : "pass"); // 输出 pass 或者 fail
cout << (grade < 60) ? "fail" : "pass"; // 输出 1 或者 0
cout << grade < 60 ? "fail" : "pass"; // 错误：试图比较 cout 和 60
```

在第二条表达式中， `grade` 和 `60` 的比较结果是 `<<` 运算符的运算对象，因此如果 `grade < 60` 为真输出 `1`，否则输出 `0`。`<<` 运算符的返回值是 `cout`，接下来 `cout` 作为条件运算符的条件。也就是说，第二条表达式等价于

```c++
cout << (grade < 60);     // 输出 1 或者 0
cout ? "fail" : "pass";   // 根据 cout 的值是 true 还是 false 产生对应的字面值
```

因为第三条表达式等价于下面的语句，所以它是错误的：

```c++
cout << grade;                 // 小于运算符的优先级低于移位运算符，所以先输出 grade
cout < 60 ? "fail" : "pass";   // 然后比较 count 和 60
```

## 4.8 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。

| 运算符 | 功能 | 用法 |
| :------: | :------: | :------: |
| ~  | 位求反 | ~ expr            |
| << | 左移   | expr << expr      |
| >> | 右移   | expr >> expr      |
| &  | 位与   | expr & expr       |
| ^  | 位异或 | expr ^ expr       |
| `|`| 位或   | `expr | expr`     |

一般来说，如果运算对象是 “小整型”，则它的值会被自动提升成较大的整数类型。

**移位运算符**

**左移运算符**（<<）在右侧插入值为 `0` 的二进制位。**右移运算符**（>>）的行为则依赖于其左侧运算对象的类型：如果左侧运算对象是无符号类型，在左侧插入值为 `0` 的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为 `0` 的二进制位，如果选择要视具体环境而定。

**位求反运算符**

**位求反运算符**（~）将运算对象逐位求反后生成一个新值，将 `1` 置为 `0`、`0` 置为 `1`。

**位与、位或、位异或运算符**

- **位与运算符**（&）：如果两个运算对象的对应位置都是 `1` 则运算结果中该位为 `1`，否则为 `0`。
- **位或运算符**（|）：如果两个运算对象的对应位置至少有一个为 `1` 则运算结果中该位为 `1`，否则为 `0`。
- **位异或运算符**（&）：如果两个运算对象的对应位置有且只有一个为 `1` 则运算结果中该位为 `1`，否则为 `0`。

## 4.9 sizeof 运算符

`sizeof` 运算符返回一条表达式或一个类型名字所占的字节数。`sizeof` 满足右结合律，其所得的值是一个 `sizt_t` 类型的常量表达式。运算符的运算对象有两种形式：

```c++
sizeof (type)
sizeof expr
```

在第二种形式中，`sizeof` 返回的是表达式结果类型的大小。与众不同的一点是，`sizeof` 并不实际计算其运算对象的值：

```c++
Sales_data data, *p;
sizeof(Sales_data);             // 存储 Sales_data 类型的对象所占的空间大小
sizeof data;                    // data 的类型的大小，即 sizeof(Sales_data)
sizeof p;                       // 指针所占的空间大小
sizeof *p;                      // p 所指类型的空间大小，即 sizeof(Sales_data)
sizeof data.revenue;            // Sales_data 的 revenue 成员对应类型的大小
sizeof Sales_data::revenue      // 另一种获取 revenue 大小的方式
```

这些例子中最有趣的一个是 `sizeof *p`。首先，因为 `sizeof` 满足结合律并且与 `*` 运算符的优先级一样，所以表达式按照从右向左的顺序结合。也就是说，它等价于 `sizeof(*p)`。其次，因为 `sizeof` 不会实际求运算对象的值，所以即使 `p` 是一个无效的指针也不会有什么影响。在 `sizeof` 的运算对象中解引用一个无效指针仍然是一种安全行为，因为指针实际上并没有被真正使用。`sizeof` 不需要真的解引用指针也能知道它所指对象的类型。

`sizeof` 运算符的结果部分地依赖于其作用类型：

- 对 `char` 或者类型为 `char` 的表达式执行 `sizeof` 运算，结果得 `1`。
- 对引用类型执行 `sizeof` 运算得到被引用对象所占空间的大小。
- 对指针执行 `sizeof` 运算得到指针本身所占空间大小。
- 对解引用指针执行 `sizeof` 运算得到指针指向的对象所占空间大小，指针不需要有效。
- 对数组执行 `sizeof` 运算得到整个数组所占空间的大小，等价于对数组中所有元素各执行一个 `sizeof` 运算并将得到的结果求和。注意，`sizeof` 运算不会把数组转换成指针来处理。
- 对 `string` 对象或 `vector` 对象执行 `sizeof` 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

因为执行 `sizeof` 运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：

```c++
// sizeof(ia) / sizeof(*ia) 返回 ia 的元素数量
constexpr size_t sz = sizeof(ia) / sizeof(*ia);
int arr2[sz];    // 正确：sizeof 返回的是一个常量表达式
```

因为 `sizeof` 的返回值是一个常量表达式，所以我们可以用 `sizeof` 的结果声明数组的维度。

## 4.10 逗号运算符

**逗号运算符**含有两个运算对象，按照从左向右的顺序依次求值。

对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。

它被经常用于 `for` 循环中：

```c++
vector<int>::size_type cnt = ivec.size();
// 将把从 size 到 1 的值赋给 ivec 的元素
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) {
    ivec[ix] = cnt;
}
```

这个循环在 for 语句的表达式中递增 `ix`、递减 `cnt`，每次循环迭代 `ix` 和 `cnt` 相应改变。只要 `ix` 满足条件，我们就把当前元素设成 `cnt` 的当前值。

## 4.11 类型转换

如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联的对象或值来替代。

```c++
int ival = 3.541 + 3;  // 编译器可能会警告该运算损失了精度
```

加法运算的两个运算对象类型不同：`3.541` 的类型是 `double` 类型，`3` 的类型是 `int`。C++ 语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述的类型转换是自动进行的，无需程序员介入，因此，它们被称作**隐式转换**。

算术类型之间的隐式转换被设计得尽可能避免损失精度。很多时候，如果表达式中既有整数类型的运算对象也有浮点类型的运算对象，整型会转换成浮点型。在上面的例子中，`3` 转换成 `double` 类型，然后执行浮点数加法，所得的结果类型是 `double`。

在初始化过程中，因为被初始化的对象的类型无法改变，所以初始值被转换成该对象的类型。在上述例子中，加法得到的 `double` 类型的结果转换成了 `int` 类型，这个值用来初始化 `ival`。由 `double` 向 `int` 转换时忽略了小数部分，数值 `6` 被赋给了 `ival`。

**何时发生隐式类型转换**

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比 `int` 类型小的整型首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象也有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.1 算数转换

**整型提升**

**整型提升**负责把小整数类型转换成较大的整数类型。对于 `bool`、`char`、`signed char`、`unsigned char`、`short` 和 `unsigned short` 等类型来说，只要它们所有可能的值都存在 `int` 里，它们就会提升成 `int` 类型；否则提升成 `unsigned int` 类型。就如我们所熟知的，布尔值 `false` 提升成 `0`、`true` 提升成 `1`。

较大的 `char` 类型（`wchar_t`、`char16_t`、`char32_t`、）提升成 `int`、`unsigned int`、`long`、`unsigned long`、`long long` 和 `unsigned long long` 中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。

### 4.11.2 其他隐式类型转换

**数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：

```c++
int ia[10];      // 含有 10 个整数的数组
int *ip = ia;    // ia 转换成指向数组首元素的指针
```

当数组被用作 `decltype` 关键字的参数，或者作为取址符（`&`）、`sizeof` 及 `typeid` 等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。

**指针转换**：常量整数 `0` 或者字面值 `nullptr` 能转换成任意指针类型；指向任意非常量的指针能转换成 `void*`；指向任意对象的指针能转换成 `const void*`。

**转换成布尔类型**：存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为 0，转换结果为 `false`，否则转换结果为 `true`。

```c++
char *cp = get_string();
if (cp) /* ... */       // 如果指针 cp 不是 0，条件为真
while (*cp) /* ... */   // 如果 *cp 不是空字符，条件为真
```

**转换成常量**：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。

```c++
int i;
const int &j = i;     // 非常量转换成 const int 的引用
const int *p = &i;    // 非常量的地址转换成 const 的地址
int &r = j, *q = p;   // 错误：不允许 const 转换成非常量
```

**类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型转换。

我们之前的程序已经使用过类类型转换：1）在需要标准库 `string` 类型的地方使用 C 风格字符串；2）在条件部分读入 `istream`：

```c++
string s, t = "a value";  // 字符串字面值转换成 string 类型
while (cin >> s)          // while 的条件部分把 cin 转换成布尔值
```

条件 (`cin >> s`) 读入 `cin` 的内容并将 `cin` 作为其求值结果。条件部分本来需要一个布尔值，但是这里实际检查的是 `istream` 类型的值。幸好 IO 库定义了从 `istream` 向布尔值转换的规则，根据这一规则，`cin` 自动地转换成布尔值。所得的布尔值得到底是什么由输入流的状态决定，如果最后一次读入成功，转换得到的布尔值是 `true`；相反，如果最后一次读入不成功，转换得到的布尔值是 `false`。

### 4.11.3 显式转换

**命名的强制类型转换**

一个命名的强制类型转换具有如下形式：

```
cast-name<type>(expression);
```

其中 `type` 是转换的目标类型，`expression` 是要转换的值。如果 `type` 是引用类型，则结果是左值。`cast-name` 是 `static_cast`、`dynamic_cast`、`const_cast`、和 `reinterpret_cast` 中的一种。`dynamic_cast` 支持运行时类型识别。

**static_cast**

任何具有明确定义的类型转换，只要不包含底层 `const`，都可以使用 `static_cast`。例如，通过将一个运算对象强制转换成 `double` 类型就能使表达式执行浮点数除法：

```c++
int i, j;
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

`static_cast` 对于编译器无法自动执行的类型转换非常有用。例如，可以使用 `static_cast` 来找回存在于 `void *` 指针中的值：

```c++
void* p = &d; // 正确：任何非常量对象的地址都能存入 void*
// 正确：将 void* 转换会初始的指针类型
double *dp = static_cast<double*>(p);
```

**const_cast**

`const_cast` 只能改变运算对象的底层 `const`：

```c++
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过 p 写值是未定义的行为
```

对于常量对象转换成非常量对象的行为，我们一般将其称为“去掉 `const` 性质”。一旦我们去掉了某个对象的 `const` 性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用 `const_cast` 执行写操作就会产生未定义的结果。

```c++
const char *cp;
// 错误：static_cast 不能转换掉 const 的性质
char *p = static_cast<char*>(cp);
static_cast<string>(cp); // 正确：字符串字面值转换成 string 类型
const_cast<string>(cp);  // 错误：const_cast 只改变常量属性
```

**reinterpret_cast**

`reinterpret_cast` 通常为运算对象的位模式提供较低层次上的重新解释。

假设有如下转换：

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记 `pc` 所指的真实对象是一个 `int` 而非字符，如果把 `pc` 当成普通的字符指针使用可能在运行时发生错误。例如：

```c++
string str(pc);
```

可能导致异常的运行时行为。

使用 `reinterpret_cast` 是非常危险的。用 `pc` 初始化 `str` 的例子很好地证明了这一点。

> `reinterpret_cast` 本质上依赖于机器。要想安全地使用 `reinterpret_cast` 必须对涉及的类型和编译器实现转换过程都非常了解。

**建议：避免强制类型转换**

强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于 `reinterpret_cast` 尤其适用，因为此类类型转换总是充满了风险。每次书写一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。











































































