## 2.1 基本内置类型

1. **算术类型**包含字符、整型数、布尔值和浮点数。

2. **空类型（void）**：不对应具体的值，仅用于一些特殊场合。例如，当函数不返回任何值时使用空类型作为返回类型。

3. 类型选择的一些经验准则：

- 当明确知晓数值不可能为负时，选用无符号类型。
- 使用 `int` 执行整型运算。在实际应用中，`short` 常常显得太小而 `long` 一般和 `int` 有一样的尺寸。如果你的数值超过了 `int` 的表示范围，选用 `long long`。
- 在算术表达式中不要使用 `char` 或者 `bool`，只有在存放字符或布尔值时才使用它们。因为类型 `char` 在一些机器上是有符号的，二在另一些机器上又是无符号的，所以如果使用 `char` 进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 `signed char` 或者 `unsigned char`。
- 执行浮点运算选用 `double`，这是因为 `float` 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。 `long double` 提供的精度在一般情况下是没有必要的，况且它带来的运算时消耗也不容忽视。

## 2.2 变量

1. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

2. 定义于任何函数体之外的变量被初始化为默认值。

3. 定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值有类确定。

4. 变量声明和定义的关系

- **声明**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而**定义**负责创建与名字关联的实体。
- 如果想声明一个变量而非定义它，就在变量前添加关键字 `extern`，而不要显示地初始化变量。

```c++
extern int i;  // 声明
int j;         // 定义
```

任何包含了显示初始化的声明即成为定义。`extern` 语句如果包含初始值就不再是声明，而变成了定义：

```c++
extern double pi = 3.1416 // 定义
```

在函数体内部，如果试图初始化一个由 `extern` 关键字标记的变量，将引发错误。

**注意：** 变量只能被定义一次，但是可以被多次声明。

5. C++的标识符有字母、数字和下划线组成，其中必须以字母或下划线开头。长度没有限制，但是对大小写敏感。

6. 变量命名规范：

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如 `index`, 不要使用 `Index` 或则 `INDEX`。
- 用户自定义的类名一般以大写字母开头，如 `Sale_item`。
- 如果标识符由多个单词组成，则单词间应有明显区分，如 `student_loan` 或 `studentLoan`，不要使用 `studentloan`。

## 2.3 复合类型

### 2.3.1 引用

**引用** 为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成 `&d` 的形式来定义引用类型，其中 `d` 是声明的变量名：

```c++
int ival = 1024;
int &refVal = ival;  // refVal 指向 ival (是 ival 的另一个名字)
int &refVal2;        // 报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

### 2.3.2 指针

**指针**，与引用类似，指针也实现了对其他对象的间接访问。与引用不同的是：1）指针本身就是一个对象，允许对指针赋值和拷贝，而在指针的生命周期内他可以先后指向几个不同的对象；2）指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有不确定的值。

 **获取对象的地址**
 
 指针存放某个对象的地址，要想获取该地址，需要使用**取地址符**（&）：
 ```c++
int ival = 42;
int *p = &ival; // p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针
 ```

 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

 **利用指针访问对象**

 如果指针指向了一个对象，则允许使用**解引用符**（*）来访问该对象。解引操作仅适用于那些确实指向了某个对象的有效指针。

```c++
int ival = 42;
int *p = &ival; // p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针
std::cout << *p << std::endl; // 输出 42
 ```

 对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```c++
*p = 0;
std::cout << *p << std::endl; // 输出 0
 ```

 **空指针**

 **空指针**（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下是几个生成空指针的方法：

```c++
int *p1 = nullptr; // 等价于 int *p1 = 0;
int *p2 = 0;       // 直接将 p2 初始化为字面常量 0
// 需要首先 #include cstdlib
int *p3 = NULL;    // 等价于 int *p3 = 0;
```

使用 `nullptr` 初始化空指针的方法是在 C++ 新标准引入的。在新的标准下，现在的 C++ 程序最好使用 `nullptr`，同时尽量避免使用 `NULL`。

建议初始化所有指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为 `nullptr`。

**`void*` 指针**

**`void*`** 是一种特殊的指针类型，可用于存放任意对象的地址。一个 `void*` 指针存放一个地址，这一点和其他指针类似。不同的是，我们队该地址中到底是个什么类型的对象并不了解。

```c++
double obj = 3.14, *pd = &obj;
void *pv = &obj; // obj 可以存放任意类型的对象
pv = pd;         // pv 可以存放任意类型的指针
```

`void*` 的用途有限：1）和别的指针比较；2）作为函数的输入或输出；3）赋给另一个 `void*` 指针。不能直接操作 `void*` 指针所指的对象，因为并不知道这个对象到底是什么类型。

### 2.3.3 理解复合类型的声明

**定义多个变量**

下面的写法容易产生误导，有可能会误认为 `p1` 和 `p2` 都是指针：
```c++
int* p1, p2; // p1 是指向 int 的指针，p2 是 int
```

涉及指针或引用的声明，一般有以下两种写法：
```c++
// 第一种
int *p1, *p2;

// 第二种
int *p1;
int *p2;
```

两种写法都可以，关键是选择并坚持其中一种，不要变来变去。

**指向指针的指针**

指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地方在存放到另一个指针中。

例如：

```c++
int ival = 1024;
int *pi = &ival; // pi 指向一个 int 型的数
int **ppi = &pi; // ppi 指向一个 int 型的指针
```

**指向指针的引用**

引用本身不是一个对象，因此不能定义引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i = 42;
int *p;      // p 是一个 int 型指针
int *&r = p; // r 是一个对指针 p 的引用

r = &i;      // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i
*r = 0;      // 解引用 r 得到 i，也就是 p 指向的对象，将 i 的改为 0
```

要理解 `r` 的类型到底是什么，最简单的方法是从右往左阅读它的定义。离变量名最近的符号（此例中是 `&r` 的符号 `&`）对变量的类型有最直接的影响，因此 `r` 是一个引用。声明符的其余部分用以确定 `r` 引用的类型是什么，此例中的符号 `*` 说明 `r` 引用的是一个指针。

## 2.4 const 限定符

`const` 修饰的变量是一个常量，定义时必须初始化，一旦创建后就不能被改变。

默认状态下，const 对象仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。

有时想让一个 const 对象在文件之间共享，这种情况下，我们不希望编译器为每个文件都分别生成独立的变量。而是只在一个文件中定义 const，而在其他文件中声明并使用它。解决办法是，对于 const 变量，不管是声明还是定义都添加 `extern` 关键字，这样就只需定义一次就可以：

```c++
// file_1.cc 定义并初始化一个常量，可以被其他文件访问
extern const int bufSize = fcn();

// file_1.h 头文件
extern const int bufSize; // 与 file_1.cc 中定义的 bufSize 是同一个
```

### 2.4.1 const 的引用

可以把引用绑定到 const 对象，称为**对常量的引用**。

```c++
const int ci = 1024;
const int &r1 = ci; // 正确：引用及其对应的对象都是常量

r1 = 42;            // 错误：r1 是对常量的引用
int &r2 = ci;       // 错误：试图让一个非常量引用指向一个常量的对象
```

**初始化和对 const 的引用**

引用的类型必须与其所引用的对象的类型一致。但是也有例外，例如在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。

```c++
int i = 1024;
const int &r1 = i;      // 允许将 const int& 绑定到一个普通 int 对象上
const int &r2 = 42;     // 正确：r1 是一个常量引用
const int &r3 = r1 * 2; // 正确：r2 是一个常量引用
int &r4 = r1 * 2;       // 错误：r4 是一个普通的非常亮引用
```

**对 const 的引用可能引用一个并非 const 的对象**

常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i;       // 引用 r1 绑定对象 i
const int &r2 = i; // r2 也绑定到对象 i，但是不允许通过 r2 修改 i 的值
r1 = 0;            // r1 并非常量，i 的值修改为 0
r2 - 0;            // 错误：r2 是一个常量引用
```

### 2.4.2 指针和 const

**指向常量的指针**不能用于改变其所指向对象的值。要向存放常量对象的地址，必须使用指向常量的指针：

```c++
const double pi = 3.14;   // pi 是常量，它的值不能改变
double *pri = &pi;        // 错误：ptr 是一个普通指针
const double *cptr = &pi; // 正确：cptr 可以指向一个双精度常量
*cptr = 42;               // 错误：不能给 *cptr 赋值
```

允许令一个指向常量的指针指向一个非常量对象：

```c++
double dval = 3.14;  // 变量，值可以改变
cptr = &dval;        // 正确：但是不能通过 cptr 改变 dval 的值
```

和常量引用一样，指向常量的指针也没有规定其所知的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定位常量。**常量对象**必须初始化，一旦初始化完成，则它的值（存放在指针中的地址）就不能再改变了。把 `*` 放在 const 关键字之前说明指针是一个常量，这样的书写形式意味着，不变的是指针本身的值，而不是指向的那个值。

```c++
int errNumb = 0;
int *const curErr = &errNumb;  // curErr 将一直指向 errNumb
const double pi = 3.14159;
const double *const pip = &pi; // pip 是一个指向常量对象的常量指针
```

理解这些声明的含义的办法是从右向左阅读。此例中，离 `curErr` 最近的符号是 `const`，意味着 `curErr` 本身是一个常量对象，对象的类型由声明符的其他部分确定，下一个符号是 `*`，意思是 `curErr` 是一个常量指针，最后 `int` 表示这个常量指针指向一个 `int` 对象。与之相似，能推断出 `pip` 是一个常量指针，指向一个双精度浮点型常量。

### 2.4.3 顶层 const

用名词**顶层 const**表示指针本身是一个常量；用名词**底层 const**表示指针所指的对象是一个常量。

当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者说两个对象的数据类型必须能转换。一般来说，非常量可以转换成常量，反之则不行：

```c++
int i = 0;
const int ci = 42;
const int *p2 = &ci;
const int *const p3 = p2;
int *p = p3;                // 错误：p3 包含底层 const 的定义，而 p 没有
p2 = p3;                    // 正确：都是底层 const
p2 = &i;                    // 正确：int* 能转换成 const int*
int &r = ci;                // 错误：普通 int& 不能绑定到 int 常量上
const int &r2 = i;          // 正确：const int&可以绑定到一个普通 int 上
```

### 2.4.3 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程就能得到计算结果的表达式。

C++11 新标准规定，允许将变量声明为 `constexpr` 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 `constexpr` 的变量一定是一个常量，而且必须用常量表达式初始化：

**constexpr 变量**

```c++
constexpr int mf = 20;         // 20 是常量表达式
constexpr int limit = mf + 1;  // mf + 1 是常量表达式
// 只有当 size 是一个 constexpr 函数时才是一条正确的声明语句
constexpr int sz = size(); 
```

> **建议**：如果你认定变量时一个常量表达式，那就把它声明为 `constexpr` 类型。

**字面值类型**

算数类型、引用和指针都属于字面值类型。 

尽管指针和引用都能定义成 `constexpr`，但是它们的初始值受到严格的限制。一个 `constexpr` 指针的初始值必须是 `nullptr` 或者 `0`，或者是存储于某个固定地址中的对象。

函数体内定义的变量一般来说并非存放在固定地址中，因此 `constexpr` 指针不能指向这样的变量。

**指针和 constexpr**

在 `constexpr` 声明中如果定义了一个指针，限定符 `constexpr` 仅对指针有效，与指针所指的对象无关：

```c++
const int *p = nullptr;      // p 是一个指向整型常量的指针
constexpr int *q = nullptr;  // p 是一个指向整数的常量指针
```

这两个的区别关键在于 `constexpr` 把它所定义的对象置顶为了顶层 const。

## 2.5 处理类型

### 2.5.1 类型别名

**类型别名**是一个名字，它是某种类型的同义词。它可以让复杂的类型名字变的简单明了、易于理解和使用，帮助程序员清楚地知道使用该类型的真实目的。

有两种方法可用于定义别名：

- 传统方法使用关键字 `typedef`

```c++
typedef double wages;    // wages 是 double 的同义词
typedef wages base, *p;  // base 是 double 的同义词，p 是 double*的同义词
```

- 新标准方法使用别名声明

```c++
using SI = Sales_item; // SI 是 Sales_items 的同义词
```

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：

```c++
wages hourly, weekly; // 等价于 double hourly, weekly;
SI item;              // 等价于 Sales_item item;
```

**指针、常量和类型别名**

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果，例如下面的 `pstring` 实际上是 `char*` 的别名：

```c++
typedef char *pstring;
const pstring cstr = 0;  // cstr 是指向 char 的常量指针
const pstring *ps;       // ps 是一个指针，它的对象是指向 char 的常量指针
```

上述两条声明的基本数据类型都是 `const pstring`， const 是对给定类型的修饰。 `pstring` 实际上是指向 `char` 的指针，因此 `const pstring` 就是指向 `char` 的常量指针，而非指向常量字符的指针。

遇到一条使用了类型别名的声明语句时，人们往往错误地尝试把类型别名替换成它的本来的样子，以理解该语句的含义：

```c++
const char *cstr = 0; // 是对 const pstring cstr 的错误理解
```

这种理解是错误的。声明语句中用到 `pstring` 时，基本数据类型是指针，可是用 `char*` 重写后，数据类型就变成了 `char`， `*` 成为了声明符的一部分。改写的结果是，前置声明的是一个指向 `char` 的常量指针，改写后的形式则声明了一个指向 `const char` 的指针。

### 2.5.2 auto 类型说明符

C++11 引入了 `auto`类型说明符，能让编译器替我们去分析表达式所属的类型。

```c++
auto item = v1 + v2; // item 初始化为 v1 和 v2 相加的结果
```

使用 `auto` 也能在一条语句中声明多个变量。因为一条声明语句中只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型必须一致：

```c++
auto i = 0, *p = &i;      // 正确：i 是整数，p 是整型指针
auto sz = 0, pi = 3.14;   // 错误：sz 和 pi 的类型不一致
```

**复合类型、常量和 auto**

编译器推断出来的 `auto` 类型有时和初始值类型并不完全一样，编译器会适当地改变结果类型使其跟符合初始化规则。

```c++
int i = 0, &r = i;
auto a = r;           // a 是一个整数（r 是 i 的别名，而 i 是一个整数）
```

其次 `auto` 一般会忽略顶层 const，保留底层 const。例如：

```c++
const int ci = i, &cr = ci;
auto b = ci;  // b 是一个整数，ci 的顶层 const 特性被忽略了
auto c = cr;  // c 是一个整数，cr 是 ci 的别名，ci 本身是一个顶层 const
auto d = &i;  // d 是一个整型指针（整数的地址就是指向整数的指针）
auto e = &ci; // e 是一个指向整数常量的指针（对常量对象取地址是一种底层 const）
```

如果希望推断出的 `auto` 类型是一个顶层 const，需要明确指出：

```c++
const auto f = ci; // ci 的推演类型是 int，f 是 const int
```

还可以将引用的类型设置为 `auto`，此时原来的初始化规则仍然适用：

```c++
auto &g = ci;        // g 是一个整型常量引用，绑定到 ci
auto &h = 42;        // 错误：不能为非常量引用绑定到字面值
const auto &j = 42;  // 正确：可以为常量引用绑定到字面值
```

设置一个类型为 `auto` 的引用时，初始值中的顶层常量属性依然保留，和往常一样，如果给初始值绑定一个引用，则此时的常量就不是顶层常量了。

### 2.5.3 decltype 类型指示符

C++11 还引入了 `decltype` 类型说明符，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型
```

`decltype` 处理顶层 const 和引用的方式与 auto 有些不同。如果 `decltype` 使用的表达式是一个变量，则 `decltype` 返回该变量的类型（包括顶层 const 和引用在内）：

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;  // x 的类型是 const int
decltype(cj) y = x;  // y 的类型是 const int&，y 绑定到变量 x
decltype(cj) z;      // 错误：z 是一个引用，必须初始化
```

因为 `cj` 是一个引用， `decltype(cj)` 的结果就是引用类型，因此作为引用的 `z` 必须初始化。

**decltype 和引用**

如果 `decltype` 使用到的表达式不是一个变量，则 `decltype` 返回表达式结果对应的类型。

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是 int，因此 b 是一个未初始化的 int
decltype(*p) c;    // 错误：c 是 int&，必须初始化
```

因为 `r` 是一个引用，因此 `decltype(r)` 的结果是引用类型。 如果想让结果类型是 `r` 所指的类型，可以把 `r` 作为表达式的一部分，如 `r+0`，显然这个表达式的结果是一个具体值而非引用。

如果表达式的内容是解引用操作，则 `decltype` 将得到引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，措意 `decltype(*p)` 的结果类型就是 `int&`，而非 `int`。

`decltype` 和 `auto` 的重要区别是：  `decltype`  的结果类型与表达式的形式密切相关。有一种情况需要特别注意：对于 `decltype`，如果表达式的变量名加上一堆括号，则得到的类型与不加括号会不同。

```c++
// decltype 的表达式是加上括号的变量，结果将是引用
decltype((i)) d; // 错误：d 是 int&，必须初始化
decltype(i) e;   // 正确：e 是一个未初始化的 int
```

## 2.6 自定义数据结构

C++11 新标准规定，可以为数据成员提供一个类内初始值。创建对象时，类内初始化值将用于初始化数据成员，没有初始值的成员将被默认初始化。

确保头文件多次包含仍能正常安全工作的常用技术是**预处理器**。它在编译之前执行的一段程序，可以部分地改变我们缩写的程序。例如 `#include`，当预处理器看到 `#include` 标记时，就会用指定的头文件的内容代替 `#include`。

C++ 程序还会用到的一项预处理功能是头文件保护符，它依赖于预处理变量。使用这些功能就可以有效地防止重复包含发生：

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <string>

struct Sales_data {
    std::string bookNo = "";
    unsigned units_sold = 0;
    double revenue = 0.0;
};

#endif
```

> 预处理器变量无视 C++ 语言中关于作用于的规则。

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于呕吐文件中的类名来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。

> 头文件即使还没有包含在任何其他文件中，也应该设置保护符。头文件保护符其实很简单，程序员只要习惯性地加上就可以了。没必要太在乎你的程序到底需不需要。